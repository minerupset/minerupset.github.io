{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Miner Curiosity Welcome. I'm not sure how you got here, but you're here now. It's nice to see you. I started this blog for two reasons: To help myself keep track of tips, tricks, and other things I pick up related to the wide-world of code To maybe one day help other people answer the same questions I've had over my time I didn't make this explicitly as a training site, so if you don't like the way I explain something / it's not as elegant as it could be, I'm honestly ok with that. That's why I don't have any comments on here - no sense in feeding the trolls. I will however do my best to not post anything that's flat out wrong, though. How this site is organized In a word: haphazardly. But learning, and especially learning software, can be haphazard. It is a bit of a truism that \"Computer outputs are rarely wrong; more often, we are wrong about what input or logic we give them.\" And while I agree with this, it doesn't mean there aren't some 'magic' steps we have to take to get our apps to work. I was never good at remembering magic steps. But you know what is? A computer. I work mostly with C#, Python, and JavaScript / TypeScript (very occasionally). I often find I spend a day breaking through some wall in a project, get super distracted by life, and then a month later, I come back and can't even remember the project, let alone the wall I had to break through. This is, simply put, bad for business. So, I've started to organize different topics to help me remember what things I did to solve problems; connecting to this or that database, the best way to write a unit test, and so on. I will try and organize topics first by language, and then grouping ideas together. Where relevant, I'll also try and cross reference similar themes from one language to another, whether highlighting similarities or differences. I won't pretend I'll be deeply rigorous on those elements, but I'll try and be as consistent as I can, and cite my sources so that I'm not just a crackpot. I have historically worked exclusively with Microsoft and Windows, but I am making the push towards UNIX based systems (currently working on a Mac). There may be a bit of cross over between the Ctrl key and the Command key, but you should be able to figure that out with some quick googling. Why MkDocs? Well, why anyone picks any option - a combination of good-enough and decision fatigue. With MkDocs, it was mostly the former. The boxes it checks for me are: Simple writing platform Markdown Deployment to GitHub Pages is a breeze Basic but powerful search functionality I don't need dates and tags (for now), but instead just need very basic organization Honestly, I'll probably end up upgrading to something else in the future (if you have any recommendations, think them really hard at me, because I don't have any commenting ability) but for now, this is enough for me. Perfect is indeed, the enemy of good.","title":"Miner Curiosity"},{"location":"#miner-curiosity","text":"Welcome. I'm not sure how you got here, but you're here now. It's nice to see you. I started this blog for two reasons: To help myself keep track of tips, tricks, and other things I pick up related to the wide-world of code To maybe one day help other people answer the same questions I've had over my time I didn't make this explicitly as a training site, so if you don't like the way I explain something / it's not as elegant as it could be, I'm honestly ok with that. That's why I don't have any comments on here - no sense in feeding the trolls. I will however do my best to not post anything that's flat out wrong, though.","title":"Miner Curiosity"},{"location":"#how-this-site-is-organized","text":"In a word: haphazardly. But learning, and especially learning software, can be haphazard. It is a bit of a truism that \"Computer outputs are rarely wrong; more often, we are wrong about what input or logic we give them.\" And while I agree with this, it doesn't mean there aren't some 'magic' steps we have to take to get our apps to work. I was never good at remembering magic steps. But you know what is? A computer. I work mostly with C#, Python, and JavaScript / TypeScript (very occasionally). I often find I spend a day breaking through some wall in a project, get super distracted by life, and then a month later, I come back and can't even remember the project, let alone the wall I had to break through. This is, simply put, bad for business. So, I've started to organize different topics to help me remember what things I did to solve problems; connecting to this or that database, the best way to write a unit test, and so on. I will try and organize topics first by language, and then grouping ideas together. Where relevant, I'll also try and cross reference similar themes from one language to another, whether highlighting similarities or differences. I won't pretend I'll be deeply rigorous on those elements, but I'll try and be as consistent as I can, and cite my sources so that I'm not just a crackpot. I have historically worked exclusively with Microsoft and Windows, but I am making the push towards UNIX based systems (currently working on a Mac). There may be a bit of cross over between the Ctrl key and the Command key, but you should be able to figure that out with some quick googling.","title":"How this site is organized"},{"location":"#why-mkdocs","text":"Well, why anyone picks any option - a combination of good-enough and decision fatigue. With MkDocs, it was mostly the former. The boxes it checks for me are: Simple writing platform Markdown Deployment to GitHub Pages is a breeze Basic but powerful search functionality I don't need dates and tags (for now), but instead just need very basic organization Honestly, I'll probably end up upgrading to something else in the future (if you have any recommendations, think them really hard at me, because I don't have any commenting ability) but for now, this is enough for me. Perfect is indeed, the enemy of good.","title":"Why MkDocs?"},{"location":"csharp-hello-world/","text":"C# - Some Basics and Hello World C# Value Prop I have a confession to make: I started learning how to code in the most business-like of environments, the VBA window of Excel files. I will forever feel like 'not a real developer' because of this. Since then, I like to think I've advanced some, but at the end of the day, I'm still the same anxious consultant looking to get an accurate answer as fast as possible. VBA was good for that then, because I was almost always crunching Excel data, but now, I would say my go to language is C#. It's a good mix of familiar constructs and powerful tools and libraries, and has a wide range of application. Why C# has worked well for me: Strong typing: Don't get me wrong, I love Python because it 'just works'. But that same beauty has been a major thorn in my side in enterprise settings, making sure things are consistent throughout an application. C# is almost always strongly typed , but does have a type (dynamic) for when something might shift over time. Object-oriented structure: Call me old fashion, but I often think in terms of concrete objects. Actual things that have properties and methods that I can visualize. Not everyone thinks this way, it may even be a crutch to think this way, but it's my default. C# makes working with classes and objects simple, and I can easily visualize my tasks in an intuitive way that I can't as easily with functional programming. Wide-spread use: We all know Python gets a lot of love because it can do anything. And it's well-earned; Python is practically synonymous with machine learning and data science, it stitches together some of the most popular web apps around the world, and it's a great introductory language to boot. But C# is hardly esoteric; ASP.NET still powers many widely used websites, .NET Core can be deployed on Windows, Mac, and Linux, and .NET integrates quite seamlessly with Azure deployment (Amazon's biggest competitor in the space). Throw in some newer toys like ML.NET, and you're hardly limited with C#. Challenges with C# Fewer libraries : It seems like pip for Python and npm for NodeJS have just about every tool you could possibly think of (whether you need it or not). Microsoft's NuGet on the other hand has definitely left me with some headaches in the past. There have been improvements, but it's a far cry from a perfect set up. Too Many -azors : If you've ever seen the movie 'Dodgeball', you may recall a scene where Ben Stiller's character introduces his mercenary team of pro dodgeballers. I can't look at Razor Pages or Blazor Pages without thinking of this scene, and feeling as confused as the protagonists. I'm all for good front-end templates, but this is one part where Microsoft did lose me. Blazor seems to have been a step in the right direction with its component structure, but it still requires a boatload of configuration to make it work. Basic C# Console App - Hello World Ok, to the meat of it. Let's make a simple Hello World app. Assuming you have: Downloaded VS Code Installed the C# Extension This is actually relatively simple. Open the terminal window (Ctrl + ~), navigate to the directory of choice, and run dotnet new console . This should create the necessary files you need, such as your bin folder, your .csproj file, and your Program.cs file, which will be the main code entry point into your application. When you've done this, you should see a chunk of code that looks roughly like this: using System; namespace YOUR_PROJECT { class Program { static void Main(string[] args) { Console.WriteLine(\"Hello World!\"); } } } If you run this application with dotnet run , you should see \"Hello World!\" appear in your terminal. Now, this is one of the downsides I find with C#: like Java, there's a lot of additional magic that is required to make it work (what the hell is using System; , and what are args ?) This is in contrast to Python, where 'things just work'. While this can be frustrating at first, it doesn't take that long to learn, and once you learn, you begin to see how the guardrails help you. What the heck did I just do? In order: using System; tells the machine, \"Hey, there's a library of code called System. Please reference this library as I'm writing my code\". System contains thing like the console, the filesystem, and a lot of the basics that make a computer run Lines in C# end with ; . It's a habit you can easily pick up, don't worry about it Chunks of code are wrapped in brackets { } . This helps determine the scope of variables and methods (bigger details for later) A namespace is a collection of code. Technically, System is a namespace. It's just a grouping of a bunch of classes. In this code, YOUR_PROJECT may end up containing one class or 20 classes, so a namespace is just a way of collecting them. If you want to use a namespace in your project, you use the using keyword like you did with the System namespace I'm not going to go into depth with classes here, as any description I give would be insufficient. In short, classes are templates for objects in the world of object-oriented-programming (OOP). I may cover that later, but not today static void Main (string[] args) is a mouth full: static is a detail of the class - it means we don't need to create an instance of program to run it, we can just run it directly (detail that will make more sense later) void means the method Main doesn't return anything. It doesn't result in a string or integer or anything else, it just runs a process and stops Main is the name of the method. It's a keyword here because the complier is going to look for a Main method as the entry point to the program (string[] args) means that Main takes a in a single argument that is an array [] of strings, and that this array is called args Console.WriteLine(\"Hello World!\"); means there is an object, the Console , that has a method WriteLine , and the line we want it to write is \"Hello World!\" . Which is why when you run this, the line \"Hello World!\" appears on your console Resources and References Static vs. Strong Typing dotnet new Docs","title":"Hello World"},{"location":"csharp-hello-world/#c-some-basics-and-hello-world","text":"","title":"C# - Some Basics and Hello World"},{"location":"csharp-hello-world/#c-value-prop","text":"I have a confession to make: I started learning how to code in the most business-like of environments, the VBA window of Excel files. I will forever feel like 'not a real developer' because of this. Since then, I like to think I've advanced some, but at the end of the day, I'm still the same anxious consultant looking to get an accurate answer as fast as possible. VBA was good for that then, because I was almost always crunching Excel data, but now, I would say my go to language is C#. It's a good mix of familiar constructs and powerful tools and libraries, and has a wide range of application.","title":"C# Value Prop"},{"location":"csharp-hello-world/#basic-c-console-app-hello-world","text":"Ok, to the meat of it. Let's make a simple Hello World app. Assuming you have: Downloaded VS Code Installed the C# Extension This is actually relatively simple. Open the terminal window (Ctrl + ~), navigate to the directory of choice, and run dotnet new console . This should create the necessary files you need, such as your bin folder, your .csproj file, and your Program.cs file, which will be the main code entry point into your application. When you've done this, you should see a chunk of code that looks roughly like this: using System; namespace YOUR_PROJECT { class Program { static void Main(string[] args) { Console.WriteLine(\"Hello World!\"); } } } If you run this application with dotnet run , you should see \"Hello World!\" appear in your terminal. Now, this is one of the downsides I find with C#: like Java, there's a lot of additional magic that is required to make it work (what the hell is using System; , and what are args ?) This is in contrast to Python, where 'things just work'. While this can be frustrating at first, it doesn't take that long to learn, and once you learn, you begin to see how the guardrails help you.","title":"Basic C# Console App - Hello World"},{"location":"csharp-hello-world/#what-the-heck-did-i-just-do","text":"In order: using System; tells the machine, \"Hey, there's a library of code called System. Please reference this library as I'm writing my code\". System contains thing like the console, the filesystem, and a lot of the basics that make a computer run Lines in C# end with ; . It's a habit you can easily pick up, don't worry about it Chunks of code are wrapped in brackets { } . This helps determine the scope of variables and methods (bigger details for later) A namespace is a collection of code. Technically, System is a namespace. It's just a grouping of a bunch of classes. In this code, YOUR_PROJECT may end up containing one class or 20 classes, so a namespace is just a way of collecting them. If you want to use a namespace in your project, you use the using keyword like you did with the System namespace I'm not going to go into depth with classes here, as any description I give would be insufficient. In short, classes are templates for objects in the world of object-oriented-programming (OOP). I may cover that later, but not today static void Main (string[] args) is a mouth full: static is a detail of the class - it means we don't need to create an instance of program to run it, we can just run it directly (detail that will make more sense later) void means the method Main doesn't return anything. It doesn't result in a string or integer or anything else, it just runs a process and stops Main is the name of the method. It's a keyword here because the complier is going to look for a Main method as the entry point to the program (string[] args) means that Main takes a in a single argument that is an array [] of strings, and that this array is called args Console.WriteLine(\"Hello World!\"); means there is an object, the Console , that has a method WriteLine , and the line we want it to write is \"Hello World!\" . Which is why when you run this, the line \"Hello World!\" appears on your console","title":"What the heck did I just do?"},{"location":"csharp-hello-world/#resources-and-references","text":"Static vs. Strong Typing dotnet new Docs","title":"Resources and References"},{"location":"git-github-learnings/","text":"Git and GitHub Quick Overview There are a boatload of tutorials on git and GitHub across the internet, so I'm not going to waste a lot of time here - this tutorial here from GitLab is a great introductory one to using git on the command line. In a nutshell, git is source control. What that means is instead of saving each version of your files as \"_v1\", \"_v2\", etc., you instead track changes with git, which can compare different version, branches, etc. Now, git itself only runs locally on your machine, but that's why you extend git with GitHub (where this site is hosted as of this writing, in fact). GitHub allows you to push your code repositories to an online site (or Hub, one might call it), that allows you to work on the same code from multiple machine, share code with friends and teammates, or even deploy from a single spot. I am of two minds on how to start with git/GitHub: I started with GitHub Desktop and at the time of this writing, am trying to get better at local git and pushing it to remote repositories on GitHub. While I think that git from the command line is ultimately a useful tool, to be honest, I don't think \"in the command line\". I'm a visual person, and seeing a desktop app that I can do things from is very helpful. That being said, when you obscure some of the magic behind a UI, it can actually damage your understanding of what exactly you're doing, and git is nuanced enough that I think a strong CLI understanding of its functionality will serve you well. Git - Reminders to myself: How to add an existing project to git/GitHub This one I forget all the time - I'll start futzing around with some code, realize I like where it's going and want to source control it, and then forget the best way to do that. Assuming: git is not enabled in your folder (if it is, skip to #4): you want it on GitHub, not just local git Then take the following steps: Make a new repository on GitHub and copy the 'clone' URL (you'll need this in step #5) Open Terminal (or equivalent for your OS) in the folder you want as the parent folder on git and run the command: git init This sets up git in your local repo Now that it's ready, you want to add the files you've been working on: run the command git add . This stages all of your files (the parameter . ) with the command add so that you can actually commit them to the repository Commit the changes you just staged by running: git commit -m \"YOUR MESSAGE HERE\" The parameter -m provides the message you're putting with this specific git commit Great, now everything is working in your local git. However, you want this on GitHub, right? To do that, you need to point your local git repository at an online target repository. To do that, run the command: git remote add origin <YOUR COPIED URL HERE> What you've just told git is, \"Hey, I'm adding a remote that I will call 'origin', and its address is this URL\" Lastly, you need to push your code up. Now, there's one thing here that you only do this one time, otherwise it can cause problems later on. Run the command: git push -f origin master What you did here was say, \"git, push this code up to the origin (that I previously specified) and push it to the branch master. And do it forcefully ( -f ) because I know what I'm doing\" You only want to use the -f parameter when you for sure want to overwrite what's going on, so only use this when you know what the results will be. In this case, because we know that the repository we made on GitHub is empty, there's no issue here, but best to confirm before doing this. References: This guy's tutorial This reference on remotes This GitLab reference","title":"Git / GitHub"},{"location":"git-github-learnings/#git-and-github","text":"","title":"Git and GitHub"},{"location":"git-github-learnings/#quick-overview","text":"There are a boatload of tutorials on git and GitHub across the internet, so I'm not going to waste a lot of time here - this tutorial here from GitLab is a great introductory one to using git on the command line. In a nutshell, git is source control. What that means is instead of saving each version of your files as \"_v1\", \"_v2\", etc., you instead track changes with git, which can compare different version, branches, etc. Now, git itself only runs locally on your machine, but that's why you extend git with GitHub (where this site is hosted as of this writing, in fact). GitHub allows you to push your code repositories to an online site (or Hub, one might call it), that allows you to work on the same code from multiple machine, share code with friends and teammates, or even deploy from a single spot. I am of two minds on how to start with git/GitHub: I started with GitHub Desktop and at the time of this writing, am trying to get better at local git and pushing it to remote repositories on GitHub. While I think that git from the command line is ultimately a useful tool, to be honest, I don't think \"in the command line\". I'm a visual person, and seeing a desktop app that I can do things from is very helpful. That being said, when you obscure some of the magic behind a UI, it can actually damage your understanding of what exactly you're doing, and git is nuanced enough that I think a strong CLI understanding of its functionality will serve you well.","title":"Quick Overview"},{"location":"git-github-learnings/#git-reminders-to-myself","text":"","title":"Git - Reminders to myself:"},{"location":"git-github-learnings/#how-to-add-an-existing-project-to-gitgithub","text":"This one I forget all the time - I'll start futzing around with some code, realize I like where it's going and want to source control it, and then forget the best way to do that. Assuming: git is not enabled in your folder (if it is, skip to #4): you want it on GitHub, not just local git Then take the following steps: Make a new repository on GitHub and copy the 'clone' URL (you'll need this in step #5) Open Terminal (or equivalent for your OS) in the folder you want as the parent folder on git and run the command: git init This sets up git in your local repo Now that it's ready, you want to add the files you've been working on: run the command git add . This stages all of your files (the parameter . ) with the command add so that you can actually commit them to the repository Commit the changes you just staged by running: git commit -m \"YOUR MESSAGE HERE\" The parameter -m provides the message you're putting with this specific git commit Great, now everything is working in your local git. However, you want this on GitHub, right? To do that, you need to point your local git repository at an online target repository. To do that, run the command: git remote add origin <YOUR COPIED URL HERE> What you've just told git is, \"Hey, I'm adding a remote that I will call 'origin', and its address is this URL\" Lastly, you need to push your code up. Now, there's one thing here that you only do this one time, otherwise it can cause problems later on. Run the command: git push -f origin master What you did here was say, \"git, push this code up to the origin (that I previously specified) and push it to the branch master. And do it forcefully ( -f ) because I know what I'm doing\" You only want to use the -f parameter when you for sure want to overwrite what's going on, so only use this when you know what the results will be. In this case, because we know that the repository we made on GitHub is empty, there's no issue here, but best to confirm before doing this. References: This guy's tutorial This reference on remotes This GitLab reference","title":"How to add an existing project to git/GitHub"},{"location":"html-and-css/","text":"HTML and CSS - the Building Blocks A Reminder about Tools Web development can often look like a large, scary beast, with so many tools and steps and requirements and everything pulling every which way. This becomes true of any field, once you get deep enough into it. At the core though, it's all pretty simple: web browsers read HTML and CSS and make them look a certain way on a webpage (statically). Javascript can make your pages dynamic 1 , but we don't need that right now. HTML and CSS are all you need to build the Document Object Model (DOM) 2 and make a webpage display in a browser. Everything else on top of this - React components and Node servers and APIs and all that jazz, at the end of the day, resolve to someone somewhere having the right HTML and CSS put in front of them. Many of the core tools you'll use manipulate HTML and CSS in one way or another so that you're not manually typing out web pages. Everything else, like video encoding, downloading files, and dynamic web apps are all details that come later. HTML - Your Structure Hyper Text Markup Language 3 is a means of encoding text that you write such that a browser can read it. Basic text files wouldn't work, because we have too many complicated objects to manipulate in a browser. Instead, you tag various elements with different items in opening(< >) and closing(< />) angle brackets. For example, the little header line you see above underneath the words 'HTML - Your Structure'. That's a simple header tag, given by wrapping the letters hr in our angle brackets. Paragraphs are given with p tags. Images, web links, videos, a lot of the web can be built with basic HTML. HTML tags often have different attributes or identifiers in them. For example: <p class=\"myClass\">This is a paragraph</p> shows a paragraph that has the class attribute of myClass . This means then that we can reference our specific paragraph by finding the element of type myClass and doing some action to it. This concept is one of the core ideas behind how CSS, jQuery, and many other web technologies work; traversing the DOM, finding the elements with a given id or class, and then operating on them in some way. It would be repetitive for me to list everything about HTML here. Suffice to say: it represents the building blocks of a webpage, it is created with tags in angle brackets, these tags have various attributes associated with them, and most of the tools you use will somehow manipulate HTML or the DOM in one form or another. CSS - Your Design If HTML is the structure of a page, then the Cascading Style Sheets represent the styling that you apply to that structure. I sadly have a confession to make: I was tragically born without a sense of style. That may come as a shock, given how beautifully styled this blog is, but I felt the need to come clean. CSS allows you to apply different styling rules (alignment, color, fonts, etc.) to your HTML elements based on their type, class, id, or other features. It's important to note that CSS is, as its name says, cascading. Let's imagine you have a rule that applies a font size to every paragraph in a page, and you have a second rule that applies a different font size to the 5th paragraph. In this order, all of your paragraphs would take on the same rule, except for the 5th paragraph. It would have special rule. But if you instead listed the special rule first, and then listed the general rule, all of the paragraphs would look the same. CSS goes in order, applying each rule as it goes and overriding if necessary, so be sure and layout your rules in the order that makes the most sense. CSS - Reminders to myself: How to center things Resources and References Yes, I know that HTML and CSS can have some dynamic elements to them too, but like any high level topic, we start with the simple lies and eventually build to uncomfortable truths. Some more detail on the DOM available at this link Great resource available at w3schools","title":"Basic HTML & CSS"},{"location":"html-and-css/#html-and-css-the-building-blocks","text":"","title":"HTML and CSS - the Building Blocks"},{"location":"html-and-css/#a-reminder-about-tools","text":"Web development can often look like a large, scary beast, with so many tools and steps and requirements and everything pulling every which way. This becomes true of any field, once you get deep enough into it. At the core though, it's all pretty simple: web browsers read HTML and CSS and make them look a certain way on a webpage (statically). Javascript can make your pages dynamic 1 , but we don't need that right now. HTML and CSS are all you need to build the Document Object Model (DOM) 2 and make a webpage display in a browser. Everything else on top of this - React components and Node servers and APIs and all that jazz, at the end of the day, resolve to someone somewhere having the right HTML and CSS put in front of them. Many of the core tools you'll use manipulate HTML and CSS in one way or another so that you're not manually typing out web pages. Everything else, like video encoding, downloading files, and dynamic web apps are all details that come later.","title":"A Reminder about Tools"},{"location":"html-and-css/#html-your-structure","text":"Hyper Text Markup Language 3 is a means of encoding text that you write such that a browser can read it. Basic text files wouldn't work, because we have too many complicated objects to manipulate in a browser. Instead, you tag various elements with different items in opening(< >) and closing(< />) angle brackets. For example, the little header line you see above underneath the words 'HTML - Your Structure'. That's a simple header tag, given by wrapping the letters hr in our angle brackets. Paragraphs are given with p tags. Images, web links, videos, a lot of the web can be built with basic HTML. HTML tags often have different attributes or identifiers in them. For example: <p class=\"myClass\">This is a paragraph</p> shows a paragraph that has the class attribute of myClass . This means then that we can reference our specific paragraph by finding the element of type myClass and doing some action to it. This concept is one of the core ideas behind how CSS, jQuery, and many other web technologies work; traversing the DOM, finding the elements with a given id or class, and then operating on them in some way. It would be repetitive for me to list everything about HTML here. Suffice to say: it represents the building blocks of a webpage, it is created with tags in angle brackets, these tags have various attributes associated with them, and most of the tools you use will somehow manipulate HTML or the DOM in one form or another.","title":"HTML - Your Structure"},{"location":"html-and-css/#css-your-design","text":"If HTML is the structure of a page, then the Cascading Style Sheets represent the styling that you apply to that structure. I sadly have a confession to make: I was tragically born without a sense of style. That may come as a shock, given how beautifully styled this blog is, but I felt the need to come clean. CSS allows you to apply different styling rules (alignment, color, fonts, etc.) to your HTML elements based on their type, class, id, or other features. It's important to note that CSS is, as its name says, cascading. Let's imagine you have a rule that applies a font size to every paragraph in a page, and you have a second rule that applies a different font size to the 5th paragraph. In this order, all of your paragraphs would take on the same rule, except for the 5th paragraph. It would have special rule. But if you instead listed the special rule first, and then listed the general rule, all of the paragraphs would look the same. CSS goes in order, applying each rule as it goes and overriding if necessary, so be sure and layout your rules in the order that makes the most sense.","title":"CSS - Your Design"},{"location":"html-and-css/#css-reminders-to-myself","text":"","title":"CSS - Reminders to myself:"},{"location":"html-and-css/#how-to-center-things","text":"","title":"How to center things"},{"location":"html-and-css/#resources-and-references","text":"Yes, I know that HTML and CSS can have some dynamic elements to them too, but like any high level topic, we start with the simple lies and eventually build to uncomfortable truths. Some more detail on the DOM available at this link Great resource available at w3schools","title":"Resources and References"},{"location":"js-hello-world/","text":"JavaScript - Some Basics and Hello World JavaScript Value Prop Why JS is so useful: Honestly, I can't really enumerate reasons here - I'm still learning it myself and it's hard to say. However, there are some key points about JavaScript that make it, at the very least, unavoidable: It's the language of the web: You'll hear that time and again, and it gets a bit old, but it doesn't make it any less true. JavaScript is the language of web browsers, case closed (narrowly beat out Visual Basic of all things back in the days of NetScape). Want proof? In literally any web page in Chrome of Firefox, open the developer tools and look at the console. You're looking at JavaScript. It's used both front and back: You'll hear all kinds of opinions on whether or not Python's Flask or C#'s ASP.NET or Java's Spring make the best API layer for a given page, and that's fine. But at the end of the day, the front of the web runs on JavaScript, and with NodeJS, so can the server layer too. That means that just one language can be used to build and deploy entire websites, soup to nuts. You can do similar things with Django in Python and Blazor/Razor pages in ASP.NET, but for true full stack development, you need to have JavaScript in your toolkit. Challenges with JS It wasn't built to last: JavaScript was originally built in the space of 10 days by one developer (Brendan Eich). Now, Eich did a hell of a job, and there have been a lot of updates to JavaScript since then, but still, the foundations of the house weren't exactly planned out. Time is no longer linear: This is a product less of JavaScript itself but instead the way it's used. Think about it like this; if you send a request to a database for a list of movies on Netflix, does Netflix freeze for the next 2 seconds while it gets that info? No. It still shows you the screen and different buttons to click on, while a little spinning wheel sits there until that database call comes back. This means that things are constantly running asynchronously, with part of the page loading while another part is still being requested. This can make debugging a nightmare, as it's not a clean linear pattern like it is in most desktop-based systems. Basic JavaScript Console App - Hello World Assuming you have: Downloaded VS Code Downloaded Node.js to your machine Start a new folder in VS Code and add a file called main.js to your folder. There, type the following code: console.log(\"Hello World!\") To run this, have your terminal in your current VS Code folder and run node main.js . Now, this is obviously an incredibly simple program; it accesses the console, uses the log method, and writes 'Hello World!'. Node and JS become significantly more complicated when they start getting into async functions and various API layers with databases, but we'll tackle that later on. For now though, we can quickly get a node module up and running, and it works. This seemed too easy - what's the catch? The catch is that JavaScript has a lot of magic principles with it, and it can get weird when you're looking at what's in the browser JavaScript engine vs. what's in the server side JavaScript. Node is a relatively new technology as far as JS is concerned, and while most of its wrinkles have been ironed out, it doesn't work the way you would expect a normal program to run, with each line being executed one at a time 1 Resources and References For a good video on how the asynchronous nature of Node works, check out this video here","title":"Hello World"},{"location":"js-hello-world/#javascript-some-basics-and-hello-world","text":"","title":"JavaScript - Some Basics and Hello World"},{"location":"js-hello-world/#javascript-value-prop","text":"","title":"JavaScript Value Prop"},{"location":"js-hello-world/#basic-javascript-console-app-hello-world","text":"Assuming you have: Downloaded VS Code Downloaded Node.js to your machine Start a new folder in VS Code and add a file called main.js to your folder. There, type the following code: console.log(\"Hello World!\") To run this, have your terminal in your current VS Code folder and run node main.js . Now, this is obviously an incredibly simple program; it accesses the console, uses the log method, and writes 'Hello World!'. Node and JS become significantly more complicated when they start getting into async functions and various API layers with databases, but we'll tackle that later on. For now though, we can quickly get a node module up and running, and it works.","title":"Basic JavaScript Console App - Hello World"},{"location":"js-hello-world/#this-seemed-too-easy-whats-the-catch","text":"The catch is that JavaScript has a lot of magic principles with it, and it can get weird when you're looking at what's in the browser JavaScript engine vs. what's in the server side JavaScript. Node is a relatively new technology as far as JS is concerned, and while most of its wrinkles have been ironed out, it doesn't work the way you would expect a normal program to run, with each line being executed one at a time 1","title":"This seemed too easy - what's the catch?"},{"location":"js-hello-world/#resources-and-references","text":"For a good video on how the asynchronous nature of Node works, check out this video here","title":"Resources and References"},{"location":"legal/","text":"Legal Notices We live in a world of lawyers, so here's the deal: I am putting this code up here for myself, for me to keep track of. If in the process of that, you learn something from it, that's great and genuinely makes me happy, but if you fry your system because you tried some code I wrote and it went sideways for you, that's on you, not on me . Code is inherently a dangerous thing when used inappropriately, so just remember: Here there be dragons. As to the references I make to other people's sites: I receive no compensation or advantage by linking to these specific sites, and I do so without guaranteeing that their sites are free of viruses, malware, offensive material, or click-bait. These are references that I have used to help me learn various topics, but if they are broken, hijacked by bots, or generally irksome, I both apologize and accept no responsibility for that. It's their site to maintain, not mine. Copyright 2020 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Legal Notices"},{"location":"legal/#legal-notices","text":"We live in a world of lawyers, so here's the deal: I am putting this code up here for myself, for me to keep track of. If in the process of that, you learn something from it, that's great and genuinely makes me happy, but if you fry your system because you tried some code I wrote and it went sideways for you, that's on you, not on me . Code is inherently a dangerous thing when used inappropriately, so just remember: Here there be dragons. As to the references I make to other people's sites: I receive no compensation or advantage by linking to these specific sites, and I do so without guaranteeing that their sites are free of viruses, malware, offensive material, or click-bait. These are references that I have used to help me learn various topics, but if they are broken, hijacked by bots, or generally irksome, I both apologize and accept no responsibility for that. It's their site to maintain, not mine. Copyright 2020 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Legal Notices"},{"location":"python-hello-world/","text":"","title":"Hello World"},{"location":"vs-code-tools/","text":"VS Code Tools Useful Shortcuts to Memorize Ctrl + ~ - access the terminal Ctrl + Shift + P - Enter VS Code tools (Command Palette) Ctrl + / - Toggle commenting Making C# Development Easier in VS Code C# (powered by OmniSharp). This is what actually makes C# go. Making Python Development Easier in VS Code Making JavaScript Development Easier in VS Code Other Useful Extensions Rainbow CSV Spell check","title":"VS Code Tools"},{"location":"vs-code-tools/#vs-code-tools","text":"","title":"VS Code Tools"},{"location":"vs-code-tools/#useful-shortcuts-to-memorize","text":"Ctrl + ~ - access the terminal Ctrl + Shift + P - Enter VS Code tools (Command Palette) Ctrl + / - Toggle commenting","title":"Useful Shortcuts to Memorize"},{"location":"vs-code-tools/#making-c-development-easier-in-vs-code","text":"C# (powered by OmniSharp). This is what actually makes C# go.","title":"Making C# Development Easier in VS Code"},{"location":"vs-code-tools/#making-python-development-easier-in-vs-code","text":"","title":"Making Python Development Easier in VS Code"},{"location":"vs-code-tools/#making-javascript-development-easier-in-vs-code","text":"","title":"Making JavaScript Development Easier in VS Code"},{"location":"vs-code-tools/#other-useful-extensions","text":"Rainbow CSV Spell check","title":"Other Useful Extensions"}]}