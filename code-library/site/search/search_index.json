{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Miner Curiosity Welcome. I'm not sure how you got here, but you're here now. It's nice to see you. I started this blog for two reasons: To help myself keep track of tips, tricks, and other things I pick up related to the wide-world of code To maybe one day help other people answer the same questions I've had over my time I didn't make this explicitly as a training site, so if you don't like the way I explain something / it's not as elegant as it could be, I'm honestly ok with that. That's why I don't have any comments on here - no sense in feeding the trolls. I will however do my best to not post anything that's flat out wrong, though. How this site is organized In a word: haphazardly. But learning, and especially learning software, can be haphazard. It is a bit of a truism that \"Computer outputs are rarely wrong; more often, we are wrong about what input or logic we give them.\" And while I agree with this, it doesn't mean there aren't some 'magic' steps we have to take to get our apps to work. I was never good at remembering magic steps. But you know what is? A computer. I work mostly with C#, Python, and JavaScript / TypeScript (very occasionally). I often find I spend a day breaking through some wall in a project, get super distracted by life, and then a month later, I come back and can't even remember the project, let alone the wall I had to break through. This is, simply put, bad for business. So, I've started to organize different topics to help me remember what things I did to solve problems; connecting to this or that database, the best way to write a unit test, and so on. I will try and organize topics first by language, and then grouping ideas together. Where relevant, I'll also try and cross reference similar themes from one language to another, whether highlighting similarities or differences. I won't pretend I'll be deeply rigorous on those elements, but I'll try and be as consistent as I can, and cite my sources so that I'm not just a crackpot. I have historically worked exclusively with Microsoft and Windows, but I am making the push towards UNIX based systems (currently working on a Mac). There may be a bit of cross over between the Ctrl key and the Command key, but you should be able to figure that out with some quick searching. Acknowledgements / Where I Learn the Most I'm a big fan of internet-based learning (obviously), and there are a number of resources and teachers who have made my life significantly easier when working through coding projects: StackOverflow, despite its many flaws and fiefdoms, remains a great place to learn why the f**k something isn't working the way you'd expect. Learning to search for the right question is important, but rarely do I find nothing on the topic. YouTube, and specifically Mosh Hamedani, have been very helpful to me. Mosh makes great videos that go through a good balance of theory with the actual practical application of the next steps, and it's hard to not be impressed with his enthusiasm for the material. Documentation and GitHub issue reports are truly invaluable. They can be intimidating at first, because it's often experienced people talking about complicated things, and it's hard to follow. However, if you take your time, search for things you don't yet know, and keep notes to refer back to, you begin to absorb so much more from the docs. Note, I received no compensation for these acknowledgements. I always struggled in finding the best resources, and knowledge is best when shared Why MkDocs? Well, why anyone picks any option - a combination of good-enough and decision fatigue. With MkDocs, it was mostly the former. The boxes it checks for me are: Simple writing with Markdown Deployment to GitHub Pages is a breeze Basic but powerful search functionality Simple, effective themes (currently using Material ) I don't need dates and tags (for now), but instead just need very basic organization Honestly, I'll probably end up upgrading to something else in the future (if you have any recommendations, think them really hard at me, because I don't have any commenting ability) but for now, this is enough for me. Perfect is indeed, the enemy of good.","title":"Miner Curiosity"},{"location":"#miner-curiosity","text":"Welcome. I'm not sure how you got here, but you're here now. It's nice to see you. I started this blog for two reasons: To help myself keep track of tips, tricks, and other things I pick up related to the wide-world of code To maybe one day help other people answer the same questions I've had over my time I didn't make this explicitly as a training site, so if you don't like the way I explain something / it's not as elegant as it could be, I'm honestly ok with that. That's why I don't have any comments on here - no sense in feeding the trolls. I will however do my best to not post anything that's flat out wrong, though.","title":"Miner Curiosity"},{"location":"#how-this-site-is-organized","text":"In a word: haphazardly. But learning, and especially learning software, can be haphazard. It is a bit of a truism that \"Computer outputs are rarely wrong; more often, we are wrong about what input or logic we give them.\" And while I agree with this, it doesn't mean there aren't some 'magic' steps we have to take to get our apps to work. I was never good at remembering magic steps. But you know what is? A computer. I work mostly with C#, Python, and JavaScript / TypeScript (very occasionally). I often find I spend a day breaking through some wall in a project, get super distracted by life, and then a month later, I come back and can't even remember the project, let alone the wall I had to break through. This is, simply put, bad for business. So, I've started to organize different topics to help me remember what things I did to solve problems; connecting to this or that database, the best way to write a unit test, and so on. I will try and organize topics first by language, and then grouping ideas together. Where relevant, I'll also try and cross reference similar themes from one language to another, whether highlighting similarities or differences. I won't pretend I'll be deeply rigorous on those elements, but I'll try and be as consistent as I can, and cite my sources so that I'm not just a crackpot. I have historically worked exclusively with Microsoft and Windows, but I am making the push towards UNIX based systems (currently working on a Mac). There may be a bit of cross over between the Ctrl key and the Command key, but you should be able to figure that out with some quick searching.","title":"How this site is organized"},{"location":"#acknowledgements-where-i-learn-the-most","text":"I'm a big fan of internet-based learning (obviously), and there are a number of resources and teachers who have made my life significantly easier when working through coding projects: StackOverflow, despite its many flaws and fiefdoms, remains a great place to learn why the f**k something isn't working the way you'd expect. Learning to search for the right question is important, but rarely do I find nothing on the topic. YouTube, and specifically Mosh Hamedani, have been very helpful to me. Mosh makes great videos that go through a good balance of theory with the actual practical application of the next steps, and it's hard to not be impressed with his enthusiasm for the material. Documentation and GitHub issue reports are truly invaluable. They can be intimidating at first, because it's often experienced people talking about complicated things, and it's hard to follow. However, if you take your time, search for things you don't yet know, and keep notes to refer back to, you begin to absorb so much more from the docs. Note, I received no compensation for these acknowledgements. I always struggled in finding the best resources, and knowledge is best when shared","title":"Acknowledgements / Where I Learn the Most"},{"location":"#why-mkdocs","text":"Well, why anyone picks any option - a combination of good-enough and decision fatigue. With MkDocs, it was mostly the former. The boxes it checks for me are: Simple writing with Markdown Deployment to GitHub Pages is a breeze Basic but powerful search functionality Simple, effective themes (currently using Material ) I don't need dates and tags (for now), but instead just need very basic organization Honestly, I'll probably end up upgrading to something else in the future (if you have any recommendations, think them really hard at me, because I don't have any commenting ability) but for now, this is enough for me. Perfect is indeed, the enemy of good.","title":"Why MkDocs?"},{"location":"legal/","text":"Legal Notices We live in a world of lawyers, so here's the deal: I am putting this code up here for myself, for me to keep track of. If in the process of that, you learn something from it, that's great and genuinely makes me happy, but if you fry your system because you tried some code I wrote and it went sideways for you, that's on you, not on me . Code is inherently a dangerous thing when used inappropriately, so just remember: Here there be dragons. As to the references I make to other people's sites: I receive no compensation or advantage by linking to these specific sites, and I do so without guaranteeing that their sites are free of viruses, malware, offensive material, or worse, click-bait. These are references that I have used to help me learn various topics, but if they are broken, hijacked by bots, or generally irksome, I both apologize and accept no responsibility for that. It's their site to maintain, not mine. Lastly, while I strive to remain GDPR compliant (no Google Analytics or Disqus commenting sections), I do not undergo regular audits to prove this. However, in that same vein, I don't collect any data that I would need to audit anyway, so I think we're all good here. Copyright 2020 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Legal Notices"},{"location":"legal/#legal-notices","text":"We live in a world of lawyers, so here's the deal: I am putting this code up here for myself, for me to keep track of. If in the process of that, you learn something from it, that's great and genuinely makes me happy, but if you fry your system because you tried some code I wrote and it went sideways for you, that's on you, not on me . Code is inherently a dangerous thing when used inappropriately, so just remember: Here there be dragons. As to the references I make to other people's sites: I receive no compensation or advantage by linking to these specific sites, and I do so without guaranteeing that their sites are free of viruses, malware, offensive material, or worse, click-bait. These are references that I have used to help me learn various topics, but if they are broken, hijacked by bots, or generally irksome, I both apologize and accept no responsibility for that. It's their site to maintain, not mine. Lastly, while I strive to remain GDPR compliant (no Google Analytics or Disqus commenting sections), I do not undergo regular audits to prove this. However, in that same vein, I don't collect any data that I would need to audit anyway, so I think we're all good here. Copyright 2020 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Legal Notices"},{"location":"csharp/hello-world/","text":"C# - Some Basics and Hello World C# Value Prop I have a confession to make: I started learning how to code in the most business-like of environments, the VBA window of Excel files. I will forever feel like 'not a real developer' because of this. Since then, I like to think I've advanced some, but at the end of the day, I'm still the same anxious consultant looking to get an accurate answer as fast as possible. VBA was good for that then, because I was almost always crunching Excel data, but now, I would say my go to language is C#. It's a good mix of familiar constructs and powerful tools and libraries, and has a wide range of application. Why C# has worked well for me: Strong typing: Don't get me wrong, I love Python because it 'just works'. But that same beauty has been a major thorn in my side in enterprise settings, making sure things are consistent throughout an application. C# is almost always # resources-and-references\">strongly typed , but does have a type (dynamic) for when something might shift over time. Object-oriented structure: Call me old fashion, but I often think in terms of concrete objects. Actual things that have properties and methods that I can visualize. Not everyone thinks this way, it may even be a crutch to think this way, but it's my default. C# makes working with classes and objects simple, and I can easily visualize my tasks in an intuitive way that I can't as easily with functional programming. Wide-spread use: We all know Python gets a lot of love because it can do anything. And it's well-earned; Python is practically synonymous with machine learning and data science, it stitches together some of the most popular web apps around the world, and it's a great introductory language to boot. But C# is hardly esoteric; ASP.NET still powers many widely used websites, .NET Core can be deployed on Windows, Mac, and Linux, and .NET integrates quite seamlessly with Azure deployment (Amazon's biggest competitor in the space). Throw in some newer toys like ML.NET, and you're hardly limited with C#. Challenges with C# Fewer libraries : It seems like pip for Python and npm for NodeJS have just about every tool you could possibly think of (whether you need it or not). Microsoft's NuGet on the other hand has definitely left me with some headaches in the past. There have been improvements, but it's a far cry from a perfect set up. Too Many -azors : If you've ever seen the movie 'Dodgeball', you may recall a scene where Ben Stiller's character introduces his mercenary team of pro dodgeballers. I can't look at Razor Pages or Blazor Pages without thinking of this scene, and feeling as confused as the protagonists. I'm all for good front-end templates, but this is one part where Microsoft did lose me. Blazor seems to have been a step in the right direction with its component structure, but it still requires a boatload of configuration to make it work. Basic C# Console App - Hello World Ok, to the meat of it. Let's make a simple Hello World app. Assuming you have: Downloaded VS Code and, Installed the C# Extension This is actually relatively simple. Open the terminal window (Ctrl + ~), navigate to the directory of choice, and run # resources-and-references\"> dotnet new console . This should create the necessary files you need, such as your bin folder, your .csproj file, and your Program.cs file, which will be the main code entry point into your application. When you've done this, you should see a chunk of code that looks roughly like this: 1 2 3 4 5 6 7 8 9 10 11 12 using System ; namespace YOUR_PROJECT { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } If you run this application with dotnet run , you should see \"Hello World!\" appear in your terminal. Now, this is one of the downsides I find with C#: like Java, there's a lot of additional magic that is required to make it work (what the hell is using System; , and what are args ?) This is in contrast to Python, where 'things just work'. While this can be frustrating at first, it doesn't take that long to learn, and once you learn, you begin to see how the guardrails help you. What the heck did I just do? In order: using System; tells the machine, \"Hey, there's a library of code called System. Please reference this library as I'm writing my code\". System contains thing like the console, the filesystem, and a lot of the basics that make a computer run Lines in C# end with ; . It's a habit you can easily pick up, don't worry about it Chunks of code are wrapped in brackets { } . This helps determine the scope of variables and methods (bigger details for later) A namespace is a collection of code. Technically, System is a namespace. It's just a grouping of a bunch of classes. In this code, YOUR_PROJECT may end up containing one class or 20 classes, so a namespace is just a way of collecting them. If you want to use a namespace in your project, you use the using keyword like you did with the System namespace I'm not going to go into depth with classes here, as any description I give would be insufficient. In short, classes are templates for objects in the world of object-oriented-programming (OOP). I may cover that later, but not today static void Main (string[] args) is a mouth full: static is a detail of the class - it means we don't need to create an instance of program to run it, we can just run it directly (detail that will make more sense later) void means the method Main doesn't return anything. It doesn't result in a string or integer or anything else, it just runs a process and stops Main is the name of the method. It's a keyword here because the complier is going to look for a Main method as the entry point to the program (string[] args) means that Main takes a in a single argument that is an array [] of strings, and that this array is called args Console.WriteLine(\"Hello World!\"); means there is an object, the Console , that has a method WriteLine , and the line we want it to write is \"Hello World!\" . Which is why when you run this, the line \"Hello World!\" appears on your console Resources and References Static vs. Strong Typing dotnet new Docs","title":"Hello World"},{"location":"csharp/hello-world/#c-some-basics-and-hello-world","text":"","title":"C# - Some Basics and Hello World"},{"location":"csharp/hello-world/#c-value-prop","text":"I have a confession to make: I started learning how to code in the most business-like of environments, the VBA window of Excel files. I will forever feel like 'not a real developer' because of this. Since then, I like to think I've advanced some, but at the end of the day, I'm still the same anxious consultant looking to get an accurate answer as fast as possible. VBA was good for that then, because I was almost always crunching Excel data, but now, I would say my go to language is C#. It's a good mix of familiar constructs and powerful tools and libraries, and has a wide range of application.","title":"C# Value Prop"},{"location":"csharp/hello-world/#basic-c-console-app-hello-world","text":"Ok, to the meat of it. Let's make a simple Hello World app. Assuming you have: Downloaded VS Code and, Installed the C# Extension This is actually relatively simple. Open the terminal window (Ctrl + ~), navigate to the directory of choice, and run # resources-and-references\"> dotnet new console . This should create the necessary files you need, such as your bin folder, your .csproj file, and your Program.cs file, which will be the main code entry point into your application. When you've done this, you should see a chunk of code that looks roughly like this: 1 2 3 4 5 6 7 8 9 10 11 12 using System ; namespace YOUR_PROJECT { class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello World!\" ); } } } If you run this application with dotnet run , you should see \"Hello World!\" appear in your terminal. Now, this is one of the downsides I find with C#: like Java, there's a lot of additional magic that is required to make it work (what the hell is using System; , and what are args ?) This is in contrast to Python, where 'things just work'. While this can be frustrating at first, it doesn't take that long to learn, and once you learn, you begin to see how the guardrails help you.","title":"Basic C# Console App - Hello World"},{"location":"csharp/hello-world/#what-the-heck-did-i-just-do","text":"In order: using System; tells the machine, \"Hey, there's a library of code called System. Please reference this library as I'm writing my code\". System contains thing like the console, the filesystem, and a lot of the basics that make a computer run Lines in C# end with ; . It's a habit you can easily pick up, don't worry about it Chunks of code are wrapped in brackets { } . This helps determine the scope of variables and methods (bigger details for later) A namespace is a collection of code. Technically, System is a namespace. It's just a grouping of a bunch of classes. In this code, YOUR_PROJECT may end up containing one class or 20 classes, so a namespace is just a way of collecting them. If you want to use a namespace in your project, you use the using keyword like you did with the System namespace I'm not going to go into depth with classes here, as any description I give would be insufficient. In short, classes are templates for objects in the world of object-oriented-programming (OOP). I may cover that later, but not today static void Main (string[] args) is a mouth full: static is a detail of the class - it means we don't need to create an instance of program to run it, we can just run it directly (detail that will make more sense later) void means the method Main doesn't return anything. It doesn't result in a string or integer or anything else, it just runs a process and stops Main is the name of the method. It's a keyword here because the complier is going to look for a Main method as the entry point to the program (string[] args) means that Main takes a in a single argument that is an array [] of strings, and that this array is called args Console.WriteLine(\"Hello World!\"); means there is an object, the Console , that has a method WriteLine , and the line we want it to write is \"Hello World!\" . Which is why when you run this, the line \"Hello World!\" appears on your console","title":"What the heck did I just do?"},{"location":"csharp/hello-world/#resources-and-references","text":"Static vs. Strong Typing dotnet new Docs","title":"Resources and References"},{"location":"databases/graph-ql-intro/","text":"GraphQL: An Alternative to REST References This article on how to set up a GraphQL query system edX Course available at this link","title":"GraphQL: An Alternative to REST"},{"location":"databases/graph-ql-intro/#graphql-an-alternative-to-rest","text":"","title":"GraphQL: An Alternative to REST"},{"location":"databases/graph-ql-intro/#references","text":"This article on how to set up a GraphQL query system edX Course available at this link","title":"References"},{"location":"databases/intro-to-dbs/","text":"Intro to Databases What (and Why) Are Databases? Working with large datasets quickly and easily is a key skill in many industries. It never failed to surprise me in high budget, quick moving projects when a senior member of the team could not grasp that data wasn't just there . That we couldn't just look at the data to find the answer. In reality storing, accessing, cleaning, and maintaining large datasets is a field all unto itself. I am not an expert here, nor will I likely ever be. However, having a healthy respect for the role that data and databases play in web development is key. Databases are specialized systems and storage containers for dealing with large (>1MM rows) sets of data. These aren't just really big Excel files; they leverage specialized query languages to index tables, retrieve necessary values, join them together, and return usable answers. While there are many flavors of databases, I'm going to cover the most obvious differentiator: SQL vs. NoSQL databases. SQL vs. NoSQL SQL Reference Reference Join Reference","title":"Basic DB Information"},{"location":"databases/intro-to-dbs/#intro-to-databases","text":"","title":"Intro to Databases"},{"location":"databases/intro-to-dbs/#what-and-why-are-databases","text":"Working with large datasets quickly and easily is a key skill in many industries. It never failed to surprise me in high budget, quick moving projects when a senior member of the team could not grasp that data wasn't just there . That we couldn't just look at the data to find the answer. In reality storing, accessing, cleaning, and maintaining large datasets is a field all unto itself. I am not an expert here, nor will I likely ever be. However, having a healthy respect for the role that data and databases play in web development is key. Databases are specialized systems and storage containers for dealing with large (>1MM rows) sets of data. These aren't just really big Excel files; they leverage specialized query languages to index tables, retrieve necessary values, join them together, and return usable answers. While there are many flavors of databases, I'm going to cover the most obvious differentiator: SQL vs. NoSQL databases.","title":"What (and Why) Are Databases?"},{"location":"databases/intro-to-dbs/#sql-vs-nosql","text":"","title":"SQL vs. NoSQL"},{"location":"databases/intro-to-dbs/#sql-reference-reference","text":"","title":"SQL Reference Reference"},{"location":"databases/intro-to-dbs/#join-reference","text":"","title":"Join Reference"},{"location":"git/intro/","text":"Git and GitHub Quick Overview There are a boatload of tutorials on git and GitHub across the internet, so I'm not going to waste a lot of time here - this tutorial here from GitLab is a great introductory one to using git on the command line. In a nutshell, git is source control. What that means is instead of saving each version of your files as \"_v1\", \"_v2\", etc., you instead track changes with git, which can compare different versions and branches of files over time. Now, git itself only runs locally on your machine, but that's why you extend git with GitHub (where this site is hosted as of this writing, in fact). GitHub allows you to push your code repositories to an online site (or Hub, one might call it), that allows you to work on the same code from multiple machines, share code with friends and teammates, or even deploy from a single spot. I am of two minds on how to start with git/GitHub: I started with GitHub Desktop and at the time of this writing, am trying to get better at local git and pushing it to remote repositories on GitHub. While I think that git from the command line is ultimately a useful tool, to be honest, I have not historically thought \"in the command line\". I'm a visual person, and seeing a desktop app that I can do click and push is very helpful. That being said, when you obscure some of the magic behind a UI, it can actually damage your understanding of what exactly you're doing. Git is nuanced enough that I think a strong CLI understanding of its functionality will serve you well, so I recommend, if not starting with the git CLI, definitely don't avoid it.","title":"Git Introduction"},{"location":"git/intro/#git-and-github","text":"","title":"Git and GitHub"},{"location":"git/intro/#quick-overview","text":"There are a boatload of tutorials on git and GitHub across the internet, so I'm not going to waste a lot of time here - this tutorial here from GitLab is a great introductory one to using git on the command line. In a nutshell, git is source control. What that means is instead of saving each version of your files as \"_v1\", \"_v2\", etc., you instead track changes with git, which can compare different versions and branches of files over time. Now, git itself only runs locally on your machine, but that's why you extend git with GitHub (where this site is hosted as of this writing, in fact). GitHub allows you to push your code repositories to an online site (or Hub, one might call it), that allows you to work on the same code from multiple machines, share code with friends and teammates, or even deploy from a single spot. I am of two minds on how to start with git/GitHub: I started with GitHub Desktop and at the time of this writing, am trying to get better at local git and pushing it to remote repositories on GitHub. While I think that git from the command line is ultimately a useful tool, to be honest, I have not historically thought \"in the command line\". I'm a visual person, and seeing a desktop app that I can do click and push is very helpful. That being said, when you obscure some of the magic behind a UI, it can actually damage your understanding of what exactly you're doing. Git is nuanced enough that I think a strong CLI understanding of its functionality will serve you well, so I recommend, if not starting with the git CLI, definitely don't avoid it.","title":"Quick Overview"},{"location":"git/reminders/","text":"Git - Reminders to myself Add an existing project to git/GitHub This one I forget all the time - I'll start futzing around with some code, realize I like where it's going and want to source control it, and then forget the best way to do that. Assuming: git is not enabled in your folder (if it is, skip to #4): you want it on GitHub, not just local git Then take the following steps: Make a new repository on GitHub and copy the 'clone' URL (you'll need this in step #5) Open Terminal (or equivalent for your OS) in the folder you want as the parent folder on git and run the command: git init This sets up git in your local repo Now that it's ready, you want to add the files you've been working on: run the command git add . This stages all of your files (the parameter . ) with the command add so that you can actually commit them to the repository Commit the changes you just staged by running: git commit -m \"YOUR MESSAGE HERE\" The parameter -m provides the message you're putting with this specific git commit Great, now everything is working in your local git. However, you want this on GitHub, right? To do that, you need to point your local git repository at an online target repository. To do that, run the command: git remote add origin <YOUR COPIED URL HERE> What you've just told git is, \"Hey, I'm adding a remote that I will call 'origin', and its address is this URL\" Lastly, you need to push your code up. Now, there's one thing here that you only do this one time, otherwise it can cause problems later on. Run the command: git push -f origin master What you did here was say: \"git, push this code up to the origin (that I previously specified) and push it to the branch master. And do it forcefully ( -f ) because I know what I'm doing\" Note: you only want to use the -f parameter when you for sure want to overwrite what's going on, so only use this when you know what the results will be. In this case, because we know that the repository we made on GitHub is empty, there's no issue here, but best to confirm before doing this. References: This guy's tutorial This reference on remotes This GitLab reference Login to GitHub with the CLI Now, this one became useful in setting up a Raspberry Pi - I wanted to be able to pull code and just have that work. References: Words Create a new branch via git CLI References: This article Visualize your repository there References: This SO discussion This tutorial","title":"Git Reminders"},{"location":"git/reminders/#git-reminders-to-myself","text":"","title":"Git - Reminders to myself"},{"location":"git/reminders/#add-an-existing-project-to-gitgithub","text":"This one I forget all the time - I'll start futzing around with some code, realize I like where it's going and want to source control it, and then forget the best way to do that. Assuming: git is not enabled in your folder (if it is, skip to #4): you want it on GitHub, not just local git Then take the following steps: Make a new repository on GitHub and copy the 'clone' URL (you'll need this in step #5) Open Terminal (or equivalent for your OS) in the folder you want as the parent folder on git and run the command: git init This sets up git in your local repo Now that it's ready, you want to add the files you've been working on: run the command git add . This stages all of your files (the parameter . ) with the command add so that you can actually commit them to the repository Commit the changes you just staged by running: git commit -m \"YOUR MESSAGE HERE\" The parameter -m provides the message you're putting with this specific git commit Great, now everything is working in your local git. However, you want this on GitHub, right? To do that, you need to point your local git repository at an online target repository. To do that, run the command: git remote add origin <YOUR COPIED URL HERE> What you've just told git is, \"Hey, I'm adding a remote that I will call 'origin', and its address is this URL\" Lastly, you need to push your code up. Now, there's one thing here that you only do this one time, otherwise it can cause problems later on. Run the command: git push -f origin master What you did here was say: \"git, push this code up to the origin (that I previously specified) and push it to the branch master. And do it forcefully ( -f ) because I know what I'm doing\" Note: you only want to use the -f parameter when you for sure want to overwrite what's going on, so only use this when you know what the results will be. In this case, because we know that the repository we made on GitHub is empty, there's no issue here, but best to confirm before doing this. References: This guy's tutorial This reference on remotes This GitLab reference","title":"Add an existing project to git/GitHub"},{"location":"git/reminders/#login-to-github-with-the-cli","text":"Now, this one became useful in setting up a Raspberry Pi - I wanted to be able to pull code and just have that work. References: Words","title":"Login to GitHub with the CLI"},{"location":"git/reminders/#create-a-new-branch-via-git-cli","text":"References: This article","title":"Create a new branch via git CLI"},{"location":"git/reminders/#visualize-your-repository-there","text":"References: This SO discussion This tutorial","title":"Visualize your repository there"},{"location":"js/azure-mern-app/","text":"Making and Hosting a MERN Stack App on Azure References This article appears to have most of the steps, but we'll have to check these against what we actually experience. This article seems to be a bit more in-depth and covers the entire MERN development process. Will dig more later","title":"Making and Hosting a MERN Stack App on Azure"},{"location":"js/azure-mern-app/#making-and-hosting-a-mern-stack-app-on-azure","text":"","title":"Making and Hosting a MERN Stack App on Azure"},{"location":"js/azure-mern-app/#references","text":"This article appears to have most of the steps, but we'll have to check these against what we actually experience. This article seems to be a bit more in-depth and covers the entire MERN development process. Will dig more later","title":"References"},{"location":"js/callbacks-promises-async/","text":"JavaScript - Callbacks, Promises, and Async Why does JS need any of this? Unlike local desktop applications, websites have to deal with the reality of decentralized systems. Decentralized systems are great for parallel processing and spreading data around, but what happens if one of your partner systems is down? Or if your internet is slow? You can't have a website just not load at all - users would stop coming. Instead, the web had to be built on the fundamentals of asynchronous actions. This means that a process might finish in half a second, 5 seconds, or 15 seconds, and your website still has to function. JavaScript, being the language of the web, needs to handle this, and handle it cleanly. The methods for doing this have changed over time, starting with callbacks, then Promises, then async/await functions. I'll approach them chronologically here, but don't spend too much time on callbacks. They should be avoided when possible because of the anti-patterns they create. If you're maintaining legacy code, you should replace your callbacks with at least Promises, if not async/await functions. To start off, it's great to have a way to model and test these kinds of delayed events. The very simple JavaScript method setTimeout () will serve well in creating delayed events that could easily happen with arbitrary database / network calls. For these exercises, let's think of a very basic thing that might happen in a standard REST API construct: you call to get a specific user, then you want to get all of those users blog posts, then you want to get all of the comments on the first blog post. Three sequential API calls that all depend on each other in sequence. (Note: shout out to several various web blog posts and tutorials for coming up with similar training examples - I believe Mosh Hamedani had one on GitHub users, which is also frequently done) Callbacks: to Hell and Back Let's start with the first one, getting our user: 1 2 3 4 5 6 7 8 9 10 getUser ( 1 , ( user ) => { console . log ( user ); }); function getUser ( id , ourCallback ) { setTimeout (() => { console . log ( 'Reading user from the db...' ) ourCallback ({ id : id , userName : \"Bob\" }); }, 2000 ); } So we did two things when we called the getUser () function. We asked for user with id 1 and, when that user was found, we asked the function ourCallback () to be called. In this case, we just set an arbitrary time out of 2000ms, but it's the same idea. We took 2 seconds to find our user object { id : '1' , username : 'Bob' } and when it was returned, we simply logged it to the console using our arrow function. This gets out of hand really fast though when you have to start nesting these calls. Lets look at our example of getting that users blog posts, and then the comments on their first blog post: 1 2 3 4 5 6 7 getUser ( 1 , ( user ) => { getPosts ( user . id , ( blogPosts ) => { getComments ( blogPosts [ 0 ], ( comments ) => { console . log ( comments ); }); }); }); I haven't fleshed out each of these methods of getPosts () and getComments () , but we don't need to. This code is clear: get a user with id of 1, then get the posts associated with that user, then get the comments associated with a given post, then log those comments. This gets nested really quickly in an ugly way. This is 'Callback Hell' , when the functions and callbacks get nested and indented farther and farther (also sometimes called the Christmas tree problem). Now, we can fix this by using named functions, but honestly, it's not that much better, because you wind up just calling getUser () and that implicitly has all the other functions beneath it. Hardly good from a code readability standpoint. Promises: Save Us from Hell Promises get a bit dicey, so here is a clear defintion: A Promise is an object that holds the result of an asynchronous task Important to note here that it is a normal JavaScript object, and that it holds the eventual result of some work that will take an undetermined amount of time. It has three phases (and one nonexistent phase): Pending (it's in process) Resolved (or fulfilled, completed with a result) Rejected (or failed with some kind of error) Undefined (it's not really a state of the Promise, but the Promise doesn't exist anymore) Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function flipCoin (){ return ( Math . floor ( Math . random () * 2 ) === 0 ); } const ourPromise = new Promise (( resolve , reject ) => { setTimeout (() => { let coinTossResult = flipCoin (); if ( coinTossResult ) resolve ( 'Heads' ); else reject ( new Error ( 'Came up tails' )); }, 2000 ); }); ourPromise . then ( result => console . log ( 'Result of our Promise' , result )) . catch ( err => console . log ( 'Error' , err . message )); This is example creates a promise that essentially flips a coin and if it's 0, it's heads, if it's 1, it's tails. But let's look at our Promise: It's an object with a . then () method for if it resolves If it errors out for any reason, the . catch () method is invoked. Let's take our previous callback methods and replace them with Promises: 1 2 3 4 5 6 7 8 9 10 11 12 13 // getUser(1, (user) => { // getPosts(user.id, (blogPosts) => { // getComments(blogPosts[0], (comments) => { // console.log(comments); // }); // }); // }); getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => console . log ( 'Comment' , comments )) . catch ( err => console . log ( 'Error' , err . message )); So, this code reads a little more cleanly. It still isn't quite as clean as completely synchronous code, but it's an improvement: getUser with id of 1 once you have that user, get their posts once you have the posts, get the comments from the first post once you have the comments, log them to the console This will run patiently and sequentially, waiting until the results are completed before moving on to the next . then () statement. This is also referred to as chaining our Promise statements together. As well, if an error occurs on any step, it will go to the . catch () statement, so there's no need to error handle each then statement on the way down. Calling Multiple Promises: Get All the Promises So if you're like me, one of the first things you want to do is run a bunch of Promises simultaneously. I don't mean chaining 3 Promises back to back like we did, but run those 3 chained Promises 100 times to test performance. To do this, you need to put all of the Promise objects into an array, and make use of the Promise . all () function. This allows the separate Promise chains to run such that they're not blocking each other (asynchronously), but each individual Promise will follow its own chain of . then () statements. Let's look at how I handled this in my example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 promiseArray = []; resultArray = []; for ( let i = 0 ; i < 100 ; i ++ ){ promiseArray . push ( getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => resultArray . push ( ` ${ entry } ${ i } ` )) . catch ( err => resultArray . push ( ` ${ err . message } ${ i } ` )); ); } Promise . all ( promiseArray ) . then ( results => { console . log ( \"Results\" , results , resultArray ); }) . catch ( err => console . log ( \"Error in the overall promising\" , err . message , resultArray )); So, we've built an array that makes our group of Promises - we have them push to a separate array of results because our Promises are objects that will become undefined once they're completed, so we want to retain those results after the fact. Now note: we have our promise array essentially protected against the overall failure. What this means is that if one of our chains of getting users, then posts, then comments fails, the whole thing won't fail, because we our array of promises never has the errors passed up to them. We never pass the reject function forward. This was done intentionally in this example so that if one out of our 100 promises failed, it doesn't torpedo the other 99, but note that there are times when you do want that to fail. If so, you need to elevate that failure so that the Promise . all () call will receive the reject () call and then hit its catch () statement. This is definitely an area I need to dig more; I won't pretend this is the be-all end-all explanation of Promises, but instead a means of investigating them. I'm sure I'll be building this out as I go. Async / Await: Sugar Coated Promises We've spent all this time looking at Promise architectures, but now, we're going to get rid of it - Promises are great, and it's important to know how they work, but realistically, they have a very different flow in their structure than does normal code. It would be great to keep writing in a synchronous style, and just have Promises work. This is where async and await come in (very similar to C#'s use of async and await with C# Task objects). Below is a direct comparison of our same three versions: Callbacks, Promises, and Async/Await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //Callback Based getUser ( 1 , ( user ) => { getPosts ( user . id , ( blogPosts ) => { getComments ( blogPosts [ 0 ], ( comments ) => { console . log ( comments ); }); }); }); //Promise based getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => console . log ( 'Comment' , comments )) . catch ( err => console . log ( 'Error' , err . message )); //Async / Await based async function displayComments (){ try { const user = await getUser ( 1 ); const blogPosts = await getPosts ( user . id ); const comments = await getComments ( blogPosts [ 0 ]); console . log ( \"Comments\" , comments ); } catch ( err ){ console . log ( err . message ); } } displayComments (); So what did we do with our Async / Await functionality? Three major changes: First, we put await in front of all of our methods that return Promises. This allows us to stop chaining them together and just treat them like normal synchronous code We had to wrap all of that in an async function - JavaScript requires that functions that have await elements must be called in an asynchronous manner, so we just created our wrapper function displayComments () to handle that for us On their own, await functions don't have error handling, so we wrapped it in a traditional try ... catch block. While this may feel a bit klunkier than the elegant . catch () method we saw with Promises, it's much more consistent with the rest of the code, and consistency is always nice. Keep in mind, it's a false dichotomy to pit Promises against Async / Await functionality - they're inherently the same. Async / Await is just some syntactic sugar wrapped around Promise architecture so that we don't need to keep in mind the unique API of a Promise. This keeps us more consistent with our structures, and generally leads to better code. Does it add more lines? Yes. Yes it does. But lines are not the only metric of code readability - we've sacrificed adding a couple of additional lines to have a consistent and readable structure that flows like our remaining synchronous code. Accurate as of January 15, 2020","title":"Callbacks, Promises, & Async"},{"location":"js/callbacks-promises-async/#javascript-callbacks-promises-and-async","text":"","title":"JavaScript - Callbacks, Promises, and Async"},{"location":"js/callbacks-promises-async/#why-does-js-need-any-of-this","text":"Unlike local desktop applications, websites have to deal with the reality of decentralized systems. Decentralized systems are great for parallel processing and spreading data around, but what happens if one of your partner systems is down? Or if your internet is slow? You can't have a website just not load at all - users would stop coming. Instead, the web had to be built on the fundamentals of asynchronous actions. This means that a process might finish in half a second, 5 seconds, or 15 seconds, and your website still has to function. JavaScript, being the language of the web, needs to handle this, and handle it cleanly. The methods for doing this have changed over time, starting with callbacks, then Promises, then async/await functions. I'll approach them chronologically here, but don't spend too much time on callbacks. They should be avoided when possible because of the anti-patterns they create. If you're maintaining legacy code, you should replace your callbacks with at least Promises, if not async/await functions. To start off, it's great to have a way to model and test these kinds of delayed events. The very simple JavaScript method setTimeout () will serve well in creating delayed events that could easily happen with arbitrary database / network calls. For these exercises, let's think of a very basic thing that might happen in a standard REST API construct: you call to get a specific user, then you want to get all of those users blog posts, then you want to get all of the comments on the first blog post. Three sequential API calls that all depend on each other in sequence. (Note: shout out to several various web blog posts and tutorials for coming up with similar training examples - I believe Mosh Hamedani had one on GitHub users, which is also frequently done)","title":"Why does JS need any of this?"},{"location":"js/callbacks-promises-async/#callbacks-to-hell-and-back","text":"Let's start with the first one, getting our user: 1 2 3 4 5 6 7 8 9 10 getUser ( 1 , ( user ) => { console . log ( user ); }); function getUser ( id , ourCallback ) { setTimeout (() => { console . log ( 'Reading user from the db...' ) ourCallback ({ id : id , userName : \"Bob\" }); }, 2000 ); } So we did two things when we called the getUser () function. We asked for user with id 1 and, when that user was found, we asked the function ourCallback () to be called. In this case, we just set an arbitrary time out of 2000ms, but it's the same idea. We took 2 seconds to find our user object { id : '1' , username : 'Bob' } and when it was returned, we simply logged it to the console using our arrow function. This gets out of hand really fast though when you have to start nesting these calls. Lets look at our example of getting that users blog posts, and then the comments on their first blog post: 1 2 3 4 5 6 7 getUser ( 1 , ( user ) => { getPosts ( user . id , ( blogPosts ) => { getComments ( blogPosts [ 0 ], ( comments ) => { console . log ( comments ); }); }); }); I haven't fleshed out each of these methods of getPosts () and getComments () , but we don't need to. This code is clear: get a user with id of 1, then get the posts associated with that user, then get the comments associated with a given post, then log those comments. This gets nested really quickly in an ugly way. This is 'Callback Hell' , when the functions and callbacks get nested and indented farther and farther (also sometimes called the Christmas tree problem). Now, we can fix this by using named functions, but honestly, it's not that much better, because you wind up just calling getUser () and that implicitly has all the other functions beneath it. Hardly good from a code readability standpoint.","title":"Callbacks: to Hell and Back"},{"location":"js/callbacks-promises-async/#promises-save-us-from-hell","text":"Promises get a bit dicey, so here is a clear defintion: A Promise is an object that holds the result of an asynchronous task Important to note here that it is a normal JavaScript object, and that it holds the eventual result of some work that will take an undetermined amount of time. It has three phases (and one nonexistent phase): Pending (it's in process) Resolved (or fulfilled, completed with a result) Rejected (or failed with some kind of error) Undefined (it's not really a state of the Promise, but the Promise doesn't exist anymore) Let's look at an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function flipCoin (){ return ( Math . floor ( Math . random () * 2 ) === 0 ); } const ourPromise = new Promise (( resolve , reject ) => { setTimeout (() => { let coinTossResult = flipCoin (); if ( coinTossResult ) resolve ( 'Heads' ); else reject ( new Error ( 'Came up tails' )); }, 2000 ); }); ourPromise . then ( result => console . log ( 'Result of our Promise' , result )) . catch ( err => console . log ( 'Error' , err . message )); This is example creates a promise that essentially flips a coin and if it's 0, it's heads, if it's 1, it's tails. But let's look at our Promise: It's an object with a . then () method for if it resolves If it errors out for any reason, the . catch () method is invoked. Let's take our previous callback methods and replace them with Promises: 1 2 3 4 5 6 7 8 9 10 11 12 13 // getUser(1, (user) => { // getPosts(user.id, (blogPosts) => { // getComments(blogPosts[0], (comments) => { // console.log(comments); // }); // }); // }); getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => console . log ( 'Comment' , comments )) . catch ( err => console . log ( 'Error' , err . message )); So, this code reads a little more cleanly. It still isn't quite as clean as completely synchronous code, but it's an improvement: getUser with id of 1 once you have that user, get their posts once you have the posts, get the comments from the first post once you have the comments, log them to the console This will run patiently and sequentially, waiting until the results are completed before moving on to the next . then () statement. This is also referred to as chaining our Promise statements together. As well, if an error occurs on any step, it will go to the . catch () statement, so there's no need to error handle each then statement on the way down.","title":"Promises: Save Us from Hell"},{"location":"js/callbacks-promises-async/#calling-multiple-promises-get-all-the-promises","text":"So if you're like me, one of the first things you want to do is run a bunch of Promises simultaneously. I don't mean chaining 3 Promises back to back like we did, but run those 3 chained Promises 100 times to test performance. To do this, you need to put all of the Promise objects into an array, and make use of the Promise . all () function. This allows the separate Promise chains to run such that they're not blocking each other (asynchronously), but each individual Promise will follow its own chain of . then () statements. Let's look at how I handled this in my example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 promiseArray = []; resultArray = []; for ( let i = 0 ; i < 100 ; i ++ ){ promiseArray . push ( getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => resultArray . push ( ` ${ entry } ${ i } ` )) . catch ( err => resultArray . push ( ` ${ err . message } ${ i } ` )); ); } Promise . all ( promiseArray ) . then ( results => { console . log ( \"Results\" , results , resultArray ); }) . catch ( err => console . log ( \"Error in the overall promising\" , err . message , resultArray )); So, we've built an array that makes our group of Promises - we have them push to a separate array of results because our Promises are objects that will become undefined once they're completed, so we want to retain those results after the fact. Now note: we have our promise array essentially protected against the overall failure. What this means is that if one of our chains of getting users, then posts, then comments fails, the whole thing won't fail, because we our array of promises never has the errors passed up to them. We never pass the reject function forward. This was done intentionally in this example so that if one out of our 100 promises failed, it doesn't torpedo the other 99, but note that there are times when you do want that to fail. If so, you need to elevate that failure so that the Promise . all () call will receive the reject () call and then hit its catch () statement. This is definitely an area I need to dig more; I won't pretend this is the be-all end-all explanation of Promises, but instead a means of investigating them. I'm sure I'll be building this out as I go.","title":"Calling Multiple Promises: Get All the Promises"},{"location":"js/callbacks-promises-async/#async-await-sugar-coated-promises","text":"We've spent all this time looking at Promise architectures, but now, we're going to get rid of it - Promises are great, and it's important to know how they work, but realistically, they have a very different flow in their structure than does normal code. It would be great to keep writing in a synchronous style, and just have Promises work. This is where async and await come in (very similar to C#'s use of async and await with C# Task objects). Below is a direct comparison of our same three versions: Callbacks, Promises, and Async/Await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //Callback Based getUser ( 1 , ( user ) => { getPosts ( user . id , ( blogPosts ) => { getComments ( blogPosts [ 0 ], ( comments ) => { console . log ( comments ); }); }); }); //Promise based getUser ( 1 ) . then ( user => getPosts ( user . id )) . then ( blogPosts => getComments ( blogPosts [ 0 ])) . then ( comments => console . log ( 'Comment' , comments )) . catch ( err => console . log ( 'Error' , err . message )); //Async / Await based async function displayComments (){ try { const user = await getUser ( 1 ); const blogPosts = await getPosts ( user . id ); const comments = await getComments ( blogPosts [ 0 ]); console . log ( \"Comments\" , comments ); } catch ( err ){ console . log ( err . message ); } } displayComments (); So what did we do with our Async / Await functionality? Three major changes: First, we put await in front of all of our methods that return Promises. This allows us to stop chaining them together and just treat them like normal synchronous code We had to wrap all of that in an async function - JavaScript requires that functions that have await elements must be called in an asynchronous manner, so we just created our wrapper function displayComments () to handle that for us On their own, await functions don't have error handling, so we wrapped it in a traditional try ... catch block. While this may feel a bit klunkier than the elegant . catch () method we saw with Promises, it's much more consistent with the rest of the code, and consistency is always nice. Keep in mind, it's a false dichotomy to pit Promises against Async / Await functionality - they're inherently the same. Async / Await is just some syntactic sugar wrapped around Promise architecture so that we don't need to keep in mind the unique API of a Promise. This keeps us more consistent with our structures, and generally leads to better code. Does it add more lines? Yes. Yes it does. But lines are not the only metric of code readability - we've sacrificed adding a couple of additional lines to have a consistent and readable structure that flows like our remaining synchronous code. Accurate as of January 15, 2020","title":"Async / Await: Sugar Coated Promises"},{"location":"js/hello-jquery/","text":"JavaScript - Introduction to Front End / jQuery What is jQuery and Why Bother? Before there were discussions about React vs. Angular vs. Vue and all the other potential front-ends, jQuery was the technology for building and deploying basic dynamic functionality to web application front-ends. jQuery is used in almost 75% of the world's most popular websites (as of 2019). It is essentially a DOM-manipulation tool, creating a simple and easy layer to manipulate the DOM in real time, based on events. It also provides an easy layer for making AJAX calls (Asynchronous JavaScript + XML) to a web server. While many front-end frameworks do away with or do not require jQuery, it is one of the original technologies in the space (dating back to 2006). Even if you never use jQuery in one of your own applications, a solid understanding of its methods and principles is incredibly valuable to understand how many existing web applications function, as well as how modern front-end frameworks evolved beyond jQuery. How jQuery Operates jQuery - Reminders to Myself","title":"Hello jQuery"},{"location":"js/hello-jquery/#javascript-introduction-to-front-end-jquery","text":"","title":"JavaScript - Introduction to Front End / jQuery"},{"location":"js/hello-jquery/#what-is-jquery-and-why-bother","text":"Before there were discussions about React vs. Angular vs. Vue and all the other potential front-ends, jQuery was the technology for building and deploying basic dynamic functionality to web application front-ends. jQuery is used in almost 75% of the world's most popular websites (as of 2019). It is essentially a DOM-manipulation tool, creating a simple and easy layer to manipulate the DOM in real time, based on events. It also provides an easy layer for making AJAX calls (Asynchronous JavaScript + XML) to a web server. While many front-end frameworks do away with or do not require jQuery, it is one of the original technologies in the space (dating back to 2006). Even if you never use jQuery in one of your own applications, a solid understanding of its methods and principles is incredibly valuable to understand how many existing web applications function, as well as how modern front-end frameworks evolved beyond jQuery.","title":"What is jQuery and Why Bother?"},{"location":"js/hello-jquery/#how-jquery-operates","text":"","title":"How jQuery Operates"},{"location":"js/hello-jquery/#jquery-reminders-to-myself","text":"","title":"jQuery - Reminders to Myself"},{"location":"js/hello-react/","text":"JavaScript - Introduction to React What is React and Why Bother? React is a front-end specific library (not framework) for creating responsive user interfaces (UIs). On the back end, it does this by creating a virtual DOM that it can quickly compare over time, and then update the real DOM. This is much cheaper from a CPU and memory perspective than trying to compare the full DOM over time; it's just not realistic. How React Operates React uses a component structure, where a core App component has a number of child components (much like the parent-child relationship in the HTML DOM). These components have two key features that drive them: state{} and render() . A component's state is the data that component owns and controls. State can include simple properties, callbacks to methods, or even other React components. State is different than the properties (props) of a component, which are passed to it from a parent. With this structure, you often see stateless functional components . This means that the state is managed by a parent element, and the necessary values are passed down the component tree as props. This helps maintain code integrity, as more of the logic can be stored at a higher shared level. Along with state and props, components have a render method. This is what actually generates the markup that will be passed along into the DOM. This is written in JSX (why React files have a .jsx extension) which is very similar to JavaScript, and has some additional elements that allow for an almost HTML like structure when defining pieces for the DOM. So, state (and props) manage the data associated with a component, while the render method generates the HTML-like markup. React classes can have other methods associated with the state to generate different values and handle methods, but if a the state should be best managed at a parent level, then the React class can be changed to a React stateless component. React - A 'Hello World' Equivalent React - Reminders to Myself Use create-react-app . While it's good to understand how React is working in the background, using the out-of-the-box method really does help get things set up and rolling quickly, and you can always use eject later if you need to modify the way it's built. Don't be afraid to lift state (or push it down) if you're running into issues with the logic. Being able to quickly modify the structure is surprisingly easy in React, so long as you're passing functions correctly between different elements. When in doubt, use arrow functions; there are still weird elements within JavaScript where something may not be flowing through the way you'd expect (e.g. this.setState() suddenly isn't a function) but using arrow functions does seem to resolve that.","title":"Hello React"},{"location":"js/hello-react/#javascript-introduction-to-react","text":"","title":"JavaScript - Introduction to React"},{"location":"js/hello-react/#what-is-react-and-why-bother","text":"React is a front-end specific library (not framework) for creating responsive user interfaces (UIs). On the back end, it does this by creating a virtual DOM that it can quickly compare over time, and then update the real DOM. This is much cheaper from a CPU and memory perspective than trying to compare the full DOM over time; it's just not realistic.","title":"What is React and Why Bother?"},{"location":"js/hello-react/#how-react-operates","text":"React uses a component structure, where a core App component has a number of child components (much like the parent-child relationship in the HTML DOM). These components have two key features that drive them: state{} and render() . A component's state is the data that component owns and controls. State can include simple properties, callbacks to methods, or even other React components. State is different than the properties (props) of a component, which are passed to it from a parent. With this structure, you often see stateless functional components . This means that the state is managed by a parent element, and the necessary values are passed down the component tree as props. This helps maintain code integrity, as more of the logic can be stored at a higher shared level. Along with state and props, components have a render method. This is what actually generates the markup that will be passed along into the DOM. This is written in JSX (why React files have a .jsx extension) which is very similar to JavaScript, and has some additional elements that allow for an almost HTML like structure when defining pieces for the DOM. So, state (and props) manage the data associated with a component, while the render method generates the HTML-like markup. React classes can have other methods associated with the state to generate different values and handle methods, but if a the state should be best managed at a parent level, then the React class can be changed to a React stateless component.","title":"How React Operates"},{"location":"js/hello-react/#react-a-hello-world-equivalent","text":"","title":"React - A 'Hello World' Equivalent"},{"location":"js/hello-react/#react-reminders-to-myself","text":"Use create-react-app . While it's good to understand how React is working in the background, using the out-of-the-box method really does help get things set up and rolling quickly, and you can always use eject later if you need to modify the way it's built. Don't be afraid to lift state (or push it down) if you're running into issues with the logic. Being able to quickly modify the structure is surprisingly easy in React, so long as you're passing functions correctly between different elements. When in doubt, use arrow functions; there are still weird elements within JavaScript where something may not be flowing through the way you'd expect (e.g. this.setState() suddenly isn't a function) but using arrow functions does seem to resolve that.","title":"React - Reminders to Myself"},{"location":"js/hello-world/","text":"JavaScript - Some Basics and Hello World JavaScript Value Prop Why JS is so useful: Honestly, I can't really enumerate reasons here - I'm still learning it myself and it's hard to say. However, there are some key points about JavaScript that make it, at the very least, unavoidable: It's the language of the web: You'll hear that time and again, and it gets a bit old, but it doesn't make it any less true. JavaScript is the language of web browsers, case closed (narrowly beat out Visual Basic of all things back in the days of NetScape). Want proof? In literally any web page in Chrome of Firefox, open the developer tools and look at the console. You're looking at JavaScript. It's used both front and back: You'll hear all kinds of opinions on whether or not Python's Flask or C#'s ASP.NET or Java's Spring make the best API layer for a given page, and that's fine. But at the end of the day, the front of the web runs on JavaScript, and with NodeJS, so can the server layer too. That means that just one language can be used to build and deploy entire websites, soup to nuts. You can do similar things with Django in Python and Blazor/Razor pages in ASP.NET, but for true full stack development, you need to have JavaScript in your toolkit. Challenges with JS It wasn't built to last: JavaScript was originally built in the space of 10 days by one developer (Brendan Eich). Now, Eich did a hell of a job, and there have been a lot of updates to JavaScript since then, but still, the foundations of the house weren't exactly planned out. Time is no longer linear: This is a product less of JavaScript itself but instead the way it's used. Think about it like this; if you send a request to a database for a list of movies on Netflix, does Netflix freeze for the next 2 seconds while it gets that info? No. It still shows you the screen and different buttons to click on, while a little spinning wheel sits there until that database call comes back. This means that things are constantly running asynchronously, with part of the page loading while another part is still being requested. This can make debugging a nightmare, as it's not a clean linear pattern like it is in most desktop-based systems. Basic JavaScript Console App - Hello World Assuming you have: Downloaded VS Code Downloaded Node.js to your machine Start a new folder in VS Code and add a file called main.js to your folder. There, type the following code: 1 console . log ( \"Hello World!\" ); To run this, have your terminal in your current VS Code folder and run node main.js . Now, this is obviously an incredibly simple program; it accesses the console, uses the log method, and writes 'Hello World!'. Node and JS become significantly more complicated when they start getting into async functions and various API layers with databases, but we'll tackle that later on. For now though, we can quickly get a node module up and running, and it works. This seemed too easy - what's the catch? The catch is that JavaScript has a lot of magic principles with it, and it can get weird when you're looking at what's in the browser JavaScript engine vs. what's in the server side JavaScript. Node is a relatively new technology as far as JS is concerned, and while most of its wrinkles have been ironed out, it doesn't work the way you would expect a normal program to run, with # resources-and-references\">each line being executed one at a time 1 Resources and References For a good video on how the asynchronous nature of Node works, check out this video here","title":"Hello World"},{"location":"js/hello-world/#javascript-some-basics-and-hello-world","text":"","title":"JavaScript - Some Basics and Hello World"},{"location":"js/hello-world/#javascript-value-prop","text":"","title":"JavaScript Value Prop"},{"location":"js/hello-world/#basic-javascript-console-app-hello-world","text":"Assuming you have: Downloaded VS Code Downloaded Node.js to your machine Start a new folder in VS Code and add a file called main.js to your folder. There, type the following code: 1 console . log ( \"Hello World!\" ); To run this, have your terminal in your current VS Code folder and run node main.js . Now, this is obviously an incredibly simple program; it accesses the console, uses the log method, and writes 'Hello World!'. Node and JS become significantly more complicated when they start getting into async functions and various API layers with databases, but we'll tackle that later on. For now though, we can quickly get a node module up and running, and it works.","title":"Basic JavaScript Console App - Hello World"},{"location":"js/hello-world/#this-seemed-too-easy-whats-the-catch","text":"The catch is that JavaScript has a lot of magic principles with it, and it can get weird when you're looking at what's in the browser JavaScript engine vs. what's in the server side JavaScript. Node is a relatively new technology as far as JS is concerned, and while most of its wrinkles have been ironed out, it doesn't work the way you would expect a normal program to run, with # resources-and-references\">each line being executed one at a time 1","title":"This seemed too easy - what's the catch?"},{"location":"js/hello-world/#resources-and-references","text":"For a good video on how the asynchronous nature of Node works, check out this video here","title":"Resources and References"},{"location":"js/intro-to-webscraping/","text":"Node - Intro to Web Scraping High Level Intro Web scraping is quite simply the act of having a computer navigate to a website and copy-pasting data freely available from the website to some source of your choice, such as a database for you to reference later. What you should know is that thanks to a large case, it has been ruled that web scraping is legal so long as it's what's considered public data. Now, keep in mind; many websites say it directly violates their terms of use, and I am not telling you to go scrape literally anything. I hold no responsibility if you get in trouble scraping. However, if you want to know the mechanics, here are the basics (taken from this helpful tutorial ). Code below, by the idea is you use a 'headless browser', in this case puppeteer, to navigate to URLs of your choice and retrieve elements of the HTML DOM for you. In the example below, I direct the headless browser to a page on this site and have it retrieve the title, the source for an image, and the quote/author that appear in the footer of each of my pages. Take a look. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const puppeteer = require ( \"puppeteer\" ); //puppeteer uses async functions to operate //This makes sense given it queries a webpage over and over async function scrapeUrl ( url ) { const browser = await puppeteer . launch (); const page = await browser . newPage (); await page . goto ( url ); //These strings are the XPath of the element - //easy to get by just right-clicking on the element in the DOM const [ el ] = await page . $x ( '//*[@id=\"sql-reference-reference\"]' ); const txt = await el . getProperty ( \"textContent\" ); const pageTitle = await txt . jsonValue (); //Notice I'm creating new variables each time - it breaks if you don't //Also note, these XPaths are honestly quite brittle. Be careful const [ el2 ] = await page . $x ( \"/html/body/div/main/div/div[3]/article/p[4]/a/img\" ); const src = await el2 . getProperty ( \"src\" ); const imagePath = await src . jsonValue (); //textContent is getting me the text within the element const [ el3 ] = await page . $x ( '//*[@id=\"quotes-quote\"]' ); const txt3 = await el3 . getProperty ( \"textContent\" ); const quote = await txt3 . jsonValue (); const [ el4 ] = await page . $x ( '//*[@id=\"quotes-author\"]' ); const txt4 = await el4 . getProperty ( \"textContent\" ); const author = await txt4 . jsonValue (); //Just logging the objects to the console as objects for now //This is where I'd likely return this object for another method //to handle porting it to the db console . log ({ pageTitle , imagePath , quote , author }); //Close the browser when you're done browser . close (); } scrapeUrl ( \"https://minerupset.github.io/intro-to-dbs/\" ); To be clear, I have not yet done by homework on puppeteer, and am not sure that I am comfortable with all that it includes. However, it seems to be a legitimate enough package, and this is definitely an easy implementation. In general, JavaScript is a great language for this kind of work, as it is uniquely designed for quickly traversing the DOM and acquiring information. This step didn't include any level of writing values to a DB for later consumption, but that would be a logical next step. Accurate as of January 13, 2020","title":"Intro to Webscraping"},{"location":"js/intro-to-webscraping/#node-intro-to-web-scraping","text":"","title":"Node - Intro to Web Scraping"},{"location":"js/intro-to-webscraping/#high-level-intro","text":"Web scraping is quite simply the act of having a computer navigate to a website and copy-pasting data freely available from the website to some source of your choice, such as a database for you to reference later. What you should know is that thanks to a large case, it has been ruled that web scraping is legal so long as it's what's considered public data. Now, keep in mind; many websites say it directly violates their terms of use, and I am not telling you to go scrape literally anything. I hold no responsibility if you get in trouble scraping. However, if you want to know the mechanics, here are the basics (taken from this helpful tutorial ). Code below, by the idea is you use a 'headless browser', in this case puppeteer, to navigate to URLs of your choice and retrieve elements of the HTML DOM for you. In the example below, I direct the headless browser to a page on this site and have it retrieve the title, the source for an image, and the quote/author that appear in the footer of each of my pages. Take a look. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const puppeteer = require ( \"puppeteer\" ); //puppeteer uses async functions to operate //This makes sense given it queries a webpage over and over async function scrapeUrl ( url ) { const browser = await puppeteer . launch (); const page = await browser . newPage (); await page . goto ( url ); //These strings are the XPath of the element - //easy to get by just right-clicking on the element in the DOM const [ el ] = await page . $x ( '//*[@id=\"sql-reference-reference\"]' ); const txt = await el . getProperty ( \"textContent\" ); const pageTitle = await txt . jsonValue (); //Notice I'm creating new variables each time - it breaks if you don't //Also note, these XPaths are honestly quite brittle. Be careful const [ el2 ] = await page . $x ( \"/html/body/div/main/div/div[3]/article/p[4]/a/img\" ); const src = await el2 . getProperty ( \"src\" ); const imagePath = await src . jsonValue (); //textContent is getting me the text within the element const [ el3 ] = await page . $x ( '//*[@id=\"quotes-quote\"]' ); const txt3 = await el3 . getProperty ( \"textContent\" ); const quote = await txt3 . jsonValue (); const [ el4 ] = await page . $x ( '//*[@id=\"quotes-author\"]' ); const txt4 = await el4 . getProperty ( \"textContent\" ); const author = await txt4 . jsonValue (); //Just logging the objects to the console as objects for now //This is where I'd likely return this object for another method //to handle porting it to the db console . log ({ pageTitle , imagePath , quote , author }); //Close the browser when you're done browser . close (); } scrapeUrl ( \"https://minerupset.github.io/intro-to-dbs/\" ); To be clear, I have not yet done by homework on puppeteer, and am not sure that I am comfortable with all that it includes. However, it seems to be a legitimate enough package, and this is definitely an easy implementation. In general, JavaScript is a great language for this kind of work, as it is uniquely designed for quickly traversing the DOM and acquiring information. This step didn't include any level of writing values to a DB for later consumption, but that would be a logical next step. Accurate as of January 13, 2020","title":"High Level Intro"},{"location":"js/to-database/","text":"Connecting Node to Databases What are my database options? SQL vs. NoSQL This link offers some good material on connecting to various db platforms using Node","title":"Connecting Node to Databases"},{"location":"js/to-database/#connecting-node-to-databases","text":"","title":"Connecting Node to Databases"},{"location":"js/to-database/#what-are-my-database-options","text":"SQL vs. NoSQL This link offers some good material on connecting to various db platforms using Node","title":"What are my database options?"},{"location":"other/html-and-css/","text":"HTML and CSS - the Building Blocks A Reminder about Tools Web development can often look like a large, scary beast, with so many tools and steps and requirements and everything pulling every which way. This becomes true of any field, once you get deep enough into it. At the core though, it's all pretty simple: web browsers read HTML and CSS and make them look a certain way on a webpage (statically). Javascript can make your pages # resources-and-references\">dynamic 1 , but we don't need that right now. HTML and CSS are all you need to build the # resources-and-references\">Document Object Model (DOM) 2 and make a webpage display in a browser. Everything else on top of this - React components and Node servers and APIs and all that jazz, at the end of the day, resolve to someone somewhere having the right HTML and CSS put in front of them. Many of the core tools you'll use manipulate HTML and CSS in one way or another so that you're not manually typing out web pages. Everything else, like video encoding, downloading files, and dynamic web apps are all details that come later. HTML - Your Structure # resources-and-references\">Hyper Text Markup Language 3 is a means of encoding text that you write such that a browser can read it. Basic text files wouldn't work, because we have too many complicated objects to manipulate in a browser. Instead, you tag various elements with different items in opening(< >) and closing(< />) angle brackets. For example, the little header line you see above underneath the words 'HTML - Your Structure'. That's a simple header tag, given by wrapping the letters hr in our angle brackets. Paragraphs are given with p tags. Images, web links, videos, a lot of the web can be built with basic HTML. HTML tags often have different attributes or identifiers in them. For example: 1 < p class = \"myClass\" > This is a paragraph </ p > shows a paragraph that has the class attribute of myClass . This means then that we can reference our specific paragraph by finding the element of type myClass and doing some action to it. This concept is one of the core ideas behind how CSS, jQuery, and many other web technologies work; traversing the DOM, finding the elements with a given id or class, and then operating on them in some way. It would be repetitive for me to list everything about HTML here. Suffice to say: it represents the building blocks of a webpage, it is created with tags in angle brackets, these tags have various attributes associated with them, and most of the tools you use will somehow manipulate HTML or the DOM in one form or another. CSS - Your Design If HTML is the structure of a page, then the Cascading Style Sheets represent the styling that you apply to that structure. I sadly have a confession to make: I was tragically born without a sense of style. That may come as a shock, given how beautifully styled this blog is, but I felt the need to come clean. CSS allows you to apply different styling rules (alignment, color, fonts, etc.) to your HTML elements based on their type, class, id, or other features. It's important to note that CSS is, as its name says, cascading. Let's imagine you have a rule that applies a font size to every paragraph in a page, and you have a second rule that applies a different font size to the 5 th paragraph. In this order, all of your paragraphs would take on the same rule, except for the 5 th paragraph. It would have special rule. But if you instead listed the special rule first, and then listed the general rule, all of the paragraphs would look the same. CSS goes in order, applying each rule as it goes and overriding if necessary, so be sure and layout your rules in the order that makes the most sense. CSS - Reminders to myself: How to center things Resources and References Yes, I know that HTML and CSS can have some dynamic elements to them too, but like any high level topic, we start with the simple lies and eventually build to uncomfortable truths. Some more detail on the DOM available at this link Great resource available at w3schools","title":"Basic HTML & CSS"},{"location":"other/html-and-css/#html-and-css-the-building-blocks","text":"","title":"HTML and CSS - the Building Blocks"},{"location":"other/html-and-css/#a-reminder-about-tools","text":"Web development can often look like a large, scary beast, with so many tools and steps and requirements and everything pulling every which way. This becomes true of any field, once you get deep enough into it. At the core though, it's all pretty simple: web browsers read HTML and CSS and make them look a certain way on a webpage (statically). Javascript can make your pages # resources-and-references\">dynamic 1 , but we don't need that right now. HTML and CSS are all you need to build the # resources-and-references\">Document Object Model (DOM) 2 and make a webpage display in a browser. Everything else on top of this - React components and Node servers and APIs and all that jazz, at the end of the day, resolve to someone somewhere having the right HTML and CSS put in front of them. Many of the core tools you'll use manipulate HTML and CSS in one way or another so that you're not manually typing out web pages. Everything else, like video encoding, downloading files, and dynamic web apps are all details that come later.","title":"A Reminder about Tools"},{"location":"other/html-and-css/#html-your-structure","text":"# resources-and-references\">Hyper Text Markup Language 3 is a means of encoding text that you write such that a browser can read it. Basic text files wouldn't work, because we have too many complicated objects to manipulate in a browser. Instead, you tag various elements with different items in opening(< >) and closing(< />) angle brackets. For example, the little header line you see above underneath the words 'HTML - Your Structure'. That's a simple header tag, given by wrapping the letters hr in our angle brackets. Paragraphs are given with p tags. Images, web links, videos, a lot of the web can be built with basic HTML. HTML tags often have different attributes or identifiers in them. For example: 1 < p class = \"myClass\" > This is a paragraph </ p > shows a paragraph that has the class attribute of myClass . This means then that we can reference our specific paragraph by finding the element of type myClass and doing some action to it. This concept is one of the core ideas behind how CSS, jQuery, and many other web technologies work; traversing the DOM, finding the elements with a given id or class, and then operating on them in some way. It would be repetitive for me to list everything about HTML here. Suffice to say: it represents the building blocks of a webpage, it is created with tags in angle brackets, these tags have various attributes associated with them, and most of the tools you use will somehow manipulate HTML or the DOM in one form or another.","title":"HTML - Your Structure"},{"location":"other/html-and-css/#css-your-design","text":"If HTML is the structure of a page, then the Cascading Style Sheets represent the styling that you apply to that structure. I sadly have a confession to make: I was tragically born without a sense of style. That may come as a shock, given how beautifully styled this blog is, but I felt the need to come clean. CSS allows you to apply different styling rules (alignment, color, fonts, etc.) to your HTML elements based on their type, class, id, or other features. It's important to note that CSS is, as its name says, cascading. Let's imagine you have a rule that applies a font size to every paragraph in a page, and you have a second rule that applies a different font size to the 5 th paragraph. In this order, all of your paragraphs would take on the same rule, except for the 5 th paragraph. It would have special rule. But if you instead listed the special rule first, and then listed the general rule, all of the paragraphs would look the same. CSS goes in order, applying each rule as it goes and overriding if necessary, so be sure and layout your rules in the order that makes the most sense.","title":"CSS - Your Design"},{"location":"other/html-and-css/#css-reminders-to-myself","text":"","title":"CSS - Reminders to myself:"},{"location":"other/html-and-css/#how-to-center-things","text":"","title":"How to center things"},{"location":"other/html-and-css/#resources-and-references","text":"Yes, I know that HTML and CSS can have some dynamic elements to them too, but like any high level topic, we start with the simple lies and eventually build to uncomfortable truths. Some more detail on the DOM available at this link Great resource available at w3schools","title":"Resources and References"},{"location":"other/os-scripting/","text":"Scripting Commands There are times in my life that I love working with my hands. It can be a restorative, meditative break to spend several hours engrossed in a purely physical task and go to bed tired and fulfilled, with a real thing you can point to and say, \"See that? I did / made / destroyed that\" This is not true for most activities I do on a computer. Not that I don't love working with and/or developing software: I do. But while I will happily pass a sanding block over a stack of lumber for hours at a time, rerunning the same deploy scripts again and again is not my idea of a day spent well. We use computers to automate and remember for us; I don't want to have to remember all of the specific magic incantations I used to get something to work just right, nor do I want to have to retype it again and again each time I make a change. Luckily, operating systems today (and in the past) have lightweight, powerful tools for automating workflows. Below I've laid out how to do it in Mac and Windows, as well as some information on running jobs on a schedule as well. Terminal Scripting in MacOS The example I'll include here is the automatic script I use to deploy this site to GitHub Pages. Because this is a personal site (and not a project site, there are some additional steps that MkDocs requires one to go through. Here's what I've done to automate that process: In the overall parent directory of my site, I've created a file called 'autoDeploy'. Note, it's not 'autoDeploy.txt', or 'autoDeploy.py', but a raw 'typeless' file. We'll adjust that in a moment. In this file, write the following lines: 1 2 3 #!/bin/bash echo Hello World! What this does is first, indicate to terminal that this is to be used in the bash shell (more technical details available here ) and then second, prints the line 'Hello World!' to the terminal (using the echo command) Now that we have our script ready, we want to run it. To do that, navigate to the folder that contains the file 'autoDeploy' file (obviously you can name your file whatever you'd like) In that folder in your terminal, run the command chmod 700 autoDeploy . This sets it to be an executable file that only you can run Now it's ready: from the terminal, run the command ./autoDeploy and the words Hello World! should appear on the terminal To chain commands together, use &&. For example, in my file I run two commands: a cd to my target directory, and then mkdocs gh-deploy {...more parameters} . These are two separate commands, but I chain them together so that they will run sequentially References: Nice Hello World tutorial can be found here What chmod 700 actually means can be found here Scheduled (Cron) Jobs in MacOs References: Good summary post on mac cron jobs can be found here Command Line Scripting in Windows","title":"Terminal / Shell Scripting"},{"location":"other/os-scripting/#scripting-commands","text":"There are times in my life that I love working with my hands. It can be a restorative, meditative break to spend several hours engrossed in a purely physical task and go to bed tired and fulfilled, with a real thing you can point to and say, \"See that? I did / made / destroyed that\" This is not true for most activities I do on a computer. Not that I don't love working with and/or developing software: I do. But while I will happily pass a sanding block over a stack of lumber for hours at a time, rerunning the same deploy scripts again and again is not my idea of a day spent well. We use computers to automate and remember for us; I don't want to have to remember all of the specific magic incantations I used to get something to work just right, nor do I want to have to retype it again and again each time I make a change. Luckily, operating systems today (and in the past) have lightweight, powerful tools for automating workflows. Below I've laid out how to do it in Mac and Windows, as well as some information on running jobs on a schedule as well.","title":"Scripting Commands"},{"location":"other/os-scripting/#terminal-scripting-in-macos","text":"The example I'll include here is the automatic script I use to deploy this site to GitHub Pages. Because this is a personal site (and not a project site, there are some additional steps that MkDocs requires one to go through. Here's what I've done to automate that process: In the overall parent directory of my site, I've created a file called 'autoDeploy'. Note, it's not 'autoDeploy.txt', or 'autoDeploy.py', but a raw 'typeless' file. We'll adjust that in a moment. In this file, write the following lines: 1 2 3 #!/bin/bash echo Hello World! What this does is first, indicate to terminal that this is to be used in the bash shell (more technical details available here ) and then second, prints the line 'Hello World!' to the terminal (using the echo command) Now that we have our script ready, we want to run it. To do that, navigate to the folder that contains the file 'autoDeploy' file (obviously you can name your file whatever you'd like) In that folder in your terminal, run the command chmod 700 autoDeploy . This sets it to be an executable file that only you can run Now it's ready: from the terminal, run the command ./autoDeploy and the words Hello World! should appear on the terminal To chain commands together, use &&. For example, in my file I run two commands: a cd to my target directory, and then mkdocs gh-deploy {...more parameters} . These are two separate commands, but I chain them together so that they will run sequentially","title":"Terminal Scripting in MacOS"},{"location":"other/os-scripting/#scheduled-cron-jobs-in-macos","text":"","title":"Scheduled (Cron) Jobs in MacOs"},{"location":"other/os-scripting/#command-line-scripting-in-windows","text":"","title":"Command Line Scripting in Windows"},{"location":"other/rpi-for-development/","text":"Raspberry Pi for Development Why would I want a Pi? For those who may not know, a Raspberry Pi is a cheap, tiny computer that typically runs a modified version of the Linux operating system. They cost anywhere from $10 to $40 dollars (give or take, depending on the model), and can be used for all kinds of applications, like server hosting or internet of things (IoT) development. I've personally found it's very helpful to have a Raspberry Pi in my arsenal for the main reason (with a lot of sub reasons) that it has taught me a boatload about development operations (DevOps). Now, most actual deployment services you'll use (Heroku, Azure, AWS...) will have much easier systems and interfaces than the command line of your Pi. But guess what? If you can figure out all of the necessary shenanigans to get something to work on a Pi and actually access the info you need, you'll be able to get it to work on one of those systems. Useful Reminders Installing Node.js on a Pi How to Install Node.JS Note: I had to change step three from: tar -xzf to tar -xf I believe because his version had a .gz compression, while Node now uses a .tz compression How to Install MongoDB Updating Pi from Python 2 to Python 3 With the imminent sunset of Python 2, it is helpful to be able to update a Raspberry Pi to Python 3, especially if this can be done in an automated fashion (for future rebuilds of the pi). This actuall wound up being a bit of a production, to be honest. The core instructions can be found here at this answer on StackOverflow, BUT: there are a couple steps you need to do first: 1 2 3 sudo apt-get install build-essential checkinstall sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev sudo apt-get install libffi-dev You need to run this first otherwise you will have errors in your Python or your pip installs (I had a major headache with libffi-dev, but that seemed to be the last one for me; python3 was working, but not pip3). After the install, I wanted to delete the Python-3.8.1 folder that was floating in my home directory A fun Linux trick: sudo rm -rI Python-3.8.1 takes care of this. sudo means 'superuser do' (in other words, you have full admin privileges active, so don't do this for every command), rm is remove directory, -r is to do it recursively (so that you can remove non-empty directories) and I stops you from getting prompted all the time about permissions, just the once at the beginning. Setting Up a Headless Pi When using a Pi, it's very inconvenient to have to get out a mouse, keyboard, and monitor just to interact with it. You likely already have one computer that you work on most often; why not just that same infrastructure instead? Luckily, there are a number of ways to do this: I won't repeat all the tutorial steps here, but generally, you first want to: Enable SSH on the Pi (note, Windows may require a 3 rd party software like PuTTY to use SSH) Set a static IP address (for faster sign ons)","title":"Raspberry Pi for Development"},{"location":"other/rpi-for-development/#raspberry-pi-for-development","text":"","title":"Raspberry Pi for Development"},{"location":"other/rpi-for-development/#why-would-i-want-a-pi","text":"For those who may not know, a Raspberry Pi is a cheap, tiny computer that typically runs a modified version of the Linux operating system. They cost anywhere from $10 to $40 dollars (give or take, depending on the model), and can be used for all kinds of applications, like server hosting or internet of things (IoT) development. I've personally found it's very helpful to have a Raspberry Pi in my arsenal for the main reason (with a lot of sub reasons) that it has taught me a boatload about development operations (DevOps). Now, most actual deployment services you'll use (Heroku, Azure, AWS...) will have much easier systems and interfaces than the command line of your Pi. But guess what? If you can figure out all of the necessary shenanigans to get something to work on a Pi and actually access the info you need, you'll be able to get it to work on one of those systems.","title":"Why would I want a Pi?"},{"location":"other/rpi-for-development/#useful-reminders","text":"","title":"Useful Reminders"},{"location":"other/rpi-for-development/#installing-nodejs-on-a-pi","text":"How to Install Node.JS Note: I had to change step three from: tar -xzf to tar -xf I believe because his version had a .gz compression, while Node now uses a .tz compression How to Install MongoDB","title":"Installing Node.js on a Pi"},{"location":"other/rpi-for-development/#updating-pi-from-python-2-to-python-3","text":"With the imminent sunset of Python 2, it is helpful to be able to update a Raspberry Pi to Python 3, especially if this can be done in an automated fashion (for future rebuilds of the pi). This actuall wound up being a bit of a production, to be honest. The core instructions can be found here at this answer on StackOverflow, BUT: there are a couple steps you need to do first: 1 2 3 sudo apt-get install build-essential checkinstall sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev sudo apt-get install libffi-dev You need to run this first otherwise you will have errors in your Python or your pip installs (I had a major headache with libffi-dev, but that seemed to be the last one for me; python3 was working, but not pip3). After the install, I wanted to delete the Python-3.8.1 folder that was floating in my home directory A fun Linux trick: sudo rm -rI Python-3.8.1 takes care of this. sudo means 'superuser do' (in other words, you have full admin privileges active, so don't do this for every command), rm is remove directory, -r is to do it recursively (so that you can remove non-empty directories) and I stops you from getting prompted all the time about permissions, just the once at the beginning.","title":"Updating Pi from Python 2 to Python 3"},{"location":"other/rpi-for-development/#setting-up-a-headless-pi","text":"When using a Pi, it's very inconvenient to have to get out a mouse, keyboard, and monitor just to interact with it. You likely already have one computer that you work on most often; why not just that same infrastructure instead? Luckily, there are a number of ways to do this: I won't repeat all the tutorial steps here, but generally, you first want to: Enable SSH on the Pi (note, Windows may require a 3 rd party software like PuTTY to use SSH) Set a static IP address (for faster sign ons)","title":"Setting Up a Headless Pi"},{"location":"other/static-blog-sites/","text":"Generating a Static Blog What is a static blog? Compare MkDocs, Gatsby, Jekyll, and Hexo What about Wyam? They seem possibly interesting","title":"Generating a Static Blog"},{"location":"other/static-blog-sites/#generating-a-static-blog","text":"","title":"Generating a Static Blog"},{"location":"other/static-blog-sites/#what-is-a-static-blog","text":"Compare MkDocs, Gatsby, Jekyll, and Hexo What about Wyam? They seem possibly interesting","title":"What is a static blog?"},{"location":"other/vs-code-tools/","text":"VS Code Tools Useful Shortcuts to Memorize Ctrl + ~ - access the terminal Ctrl + Shift + P - Enter VS Code tools (Command Palette) Ctrl + / - Toggle commenting Creating Your Own Snippets Decent link for this available here . Some of the IntelliSense autofill can be weird, but it does help. You can modify your quickSuggestions settings by adding this to your settings.json file: 1 2 \"[markdown]\" : { \"editor.quickSuggestions\" : true } This will then have your snippets show up, but keep in mind, it also makes all kinds of other suggestions show up, so be careful Making C# Development Easier in VS Code C# (powered by OmniSharp). This is what actually makes C# go. Making Python Development Easier in VS Code Python Making JavaScript Development Easier in VS Code Simple React Snippets (imrc for importing React and Component, sfc for stateless functional component, etc.) Other Useful Extensions Rainbow CSV Code Spell Checker","title":"VS Code Tools"},{"location":"other/vs-code-tools/#vs-code-tools","text":"","title":"VS Code Tools"},{"location":"other/vs-code-tools/#useful-shortcuts-to-memorize","text":"Ctrl + ~ - access the terminal Ctrl + Shift + P - Enter VS Code tools (Command Palette) Ctrl + / - Toggle commenting","title":"Useful Shortcuts to Memorize"},{"location":"other/vs-code-tools/#creating-your-own-snippets","text":"Decent link for this available here . Some of the IntelliSense autofill can be weird, but it does help. You can modify your quickSuggestions settings by adding this to your settings.json file: 1 2 \"[markdown]\" : { \"editor.quickSuggestions\" : true } This will then have your snippets show up, but keep in mind, it also makes all kinds of other suggestions show up, so be careful","title":"Creating Your Own Snippets"},{"location":"other/vs-code-tools/#making-c-development-easier-in-vs-code","text":"C# (powered by OmniSharp). This is what actually makes C# go.","title":"Making C# Development Easier in VS Code"},{"location":"other/vs-code-tools/#making-python-development-easier-in-vs-code","text":"Python","title":"Making Python Development Easier in VS Code"},{"location":"other/vs-code-tools/#making-javascript-development-easier-in-vs-code","text":"Simple React Snippets (imrc for importing React and Component, sfc for stateless functional component, etc.)","title":"Making JavaScript Development Easier in VS Code"},{"location":"other/vs-code-tools/#other-useful-extensions","text":"Rainbow CSV Code Spell Checker","title":"Other Useful Extensions"},{"location":"python/hello-world/","text":"Python - Some Basics and Hello World Python Value Prop Python has been one of the fastest growing languages of the past decade. With a low barrier to entry, widespread use across operating systems, and a massive library of available modules, it's easy to understand why. Python may not always be the best language for whatever task you're tackling, but chances are there is someway it can handle the task.Python brings with it some interesting features that make it both a valuable and useful language, but can provide some headaches: The Good Clean Syntax: Python has an incredibly clean looking language that practically reads like pseudo-code in many cases. This makes it very digestible for beginners and helps show what the underlying code is doing. Massive pip Library: The sheer volume of modules that exist in pip is incredible, and while the level of maintenance differs across them, rarely have I been completely at a loss for a utility that I've needed and not wanted to write myself. Something for Every Occasion: This is an extension of the above point, but whether you're writing scripts to automate a workflow, building a web application, or doing heavy-duty data science, Python has something for that. Even this blog (at the time of this writing), is built using a Python templating engine. Because of its portability and easy consumption, Python really can be useful in just about any occasion. The Bad Sneaky Errors: Because Python doesn't use brackets (but instead uses spacing and indentation), seemingly innocuous typing errors like an extra space here or there can completely break a module. Combine that with the fact that Python is interpreted, not compiled, and it can make debugging a nightmare. There are code linters that help with this, but it's hard to get the kind of Intelli-Sense help you get in languages like C#. Pythonic to a Fault: There is an idea in Python of 'pythonicness', where code should be written with as many Python-specific features as possible. While I am all for fast, efficient code that uses the features of the language, there are many elements of pythonicness that in my opinion, go against the clean syntax mentioned above. This is especially problematic when code becomes contests of who can write the fewest characters to get an idea across. I believe strongly in the statement that you only write code 10% of the time, and the other 90% is spent maintaining, so code should be written to be read cleanly and effectively (of course assuming negligible differences in runtime). Basic Python - Hello World Assuming you have: Downloaded VS Code and, Installed the Python Extension This is quite simple. In your project directory, create a new file called 'hello.py'. In that new file, write the line: 1 print ( 'Hello World!' ) In the terminal, type the command python hello.py (in Mac or Linux, it may need to be python3 hello.py , depending on what version you have installed.) You should see 'Hello World!' show up on your console. If you don't, check and make sure that you have Python included in your PATH variables, so that you can call it from the terminal window. As you can see, unlike C#, Python is very clean; no need for using statements or namespaces or anything like that. Python is an interpreted language, which means that it is not pre-compiled into machine code the way C# and many other languages are today. It runs in real time, which can be both a blessing and a curse, depending on the application.","title":"Hello World"},{"location":"python/hello-world/#python-some-basics-and-hello-world","text":"","title":"Python - Some Basics and Hello World"},{"location":"python/hello-world/#python-value-prop","text":"Python has been one of the fastest growing languages of the past decade. With a low barrier to entry, widespread use across operating systems, and a massive library of available modules, it's easy to understand why. Python may not always be the best language for whatever task you're tackling, but chances are there is someway it can handle the task.Python brings with it some interesting features that make it both a valuable and useful language, but can provide some headaches:","title":"Python Value Prop"},{"location":"python/hello-world/#basic-python-hello-world","text":"Assuming you have: Downloaded VS Code and, Installed the Python Extension This is quite simple. In your project directory, create a new file called 'hello.py'. In that new file, write the line: 1 print ( 'Hello World!' ) In the terminal, type the command python hello.py (in Mac or Linux, it may need to be python3 hello.py , depending on what version you have installed.) You should see 'Hello World!' show up on your console. If you don't, check and make sure that you have Python included in your PATH variables, so that you can call it from the terminal window. As you can see, unlike C#, Python is very clean; no need for using statements or namespaces or anything like that. Python is an interpreted language, which means that it is not pre-compiled into machine code the way C# and many other languages are today. It runs in real time, which can be both a blessing and a curse, depending on the application.","title":"Basic Python - Hello World"},{"location":"python/intro-to-flask/","text":"Intro to Flask, Python's Microserver What is Flask? Some words describing what flask is Getting Started Reference that very kind man's medium article Great introductory tutorial here Reminders Talk about the environment stuff from the flask documentation and how the venv thing helps Flask's Documentation","title":"Intro to Flask, Python's Microserver"},{"location":"python/intro-to-flask/#intro-to-flask-pythons-microserver","text":"","title":"Intro to Flask, Python's Microserver"},{"location":"python/intro-to-flask/#what-is-flask","text":"Some words describing what flask is","title":"What is Flask?"},{"location":"python/intro-to-flask/#getting-started","text":"Reference that very kind man's medium article Great introductory tutorial here","title":"Getting Started"},{"location":"python/intro-to-flask/#reminders","text":"Talk about the environment stuff from the flask documentation and how the venv thing helps Flask's Documentation","title":"Reminders"},{"location":"python/working-with-files/","text":"Python - Working With Files Reading and Writing Files A simple yet very useful task that may come up time and again is modifying one (or many hundreds) or text files in a consistent way. Luckily, Python scripting makes this very easy. In the following example, I'm going to: Read in a file from a path Create a new file to write my modified file to Make my modification and write it (Note, you can't modify files in place: this is a limitation of streams of memory, not of Python). 1 2 3 4 5 6 7 8 9 10 path = 'path/to/startingFile.txt' newPath = '/path/to/resultFile.txt' with open ( path , 'r' ) as reader : startLines = reader . readlines () with open ( newPath , 'w' ) as writer : for line in startLines : newLine = '\"' + line . rstrip () + '\"' + ', \\n ' writer . write ( newLine ) So in lines 4 and 5 we open up the file at path and read in the entire contents into a new variable called startLines . Then, in lines 7 through 10, we open up a file writer, iterate over those start lines, and make a modification called newLine and write this to our new file. You'll notice I haven't talked about the modification I made, because it honestly doesn't matter. You'll need to make your own modifications anyway. FYI Because you asked, all I did was wrap each line in quotes and add a comma to the end. This is because I needed to add each line of the file to an array for making a VS Code snippet. This is one of the huge advantages; I saved myself a boatload of time in just 10 lines of code, and I can reuse these chunks of code again and again for all kinds of small but helpful projects. Working with the Directory It's all well and good to work with individual files themselves, and there are plenty of times that's helpful, but there are also times where you'll want to work with the filesystem itself. To do this, you'll want to work with Python's built-in os module that makes operations like this much easier.","title":"Working With Files"},{"location":"python/working-with-files/#python-working-with-files","text":"","title":"Python - Working With Files"},{"location":"python/working-with-files/#reading-and-writing-files","text":"A simple yet very useful task that may come up time and again is modifying one (or many hundreds) or text files in a consistent way. Luckily, Python scripting makes this very easy. In the following example, I'm going to: Read in a file from a path Create a new file to write my modified file to Make my modification and write it (Note, you can't modify files in place: this is a limitation of streams of memory, not of Python). 1 2 3 4 5 6 7 8 9 10 path = 'path/to/startingFile.txt' newPath = '/path/to/resultFile.txt' with open ( path , 'r' ) as reader : startLines = reader . readlines () with open ( newPath , 'w' ) as writer : for line in startLines : newLine = '\"' + line . rstrip () + '\"' + ', \\n ' writer . write ( newLine ) So in lines 4 and 5 we open up the file at path and read in the entire contents into a new variable called startLines . Then, in lines 7 through 10, we open up a file writer, iterate over those start lines, and make a modification called newLine and write this to our new file. You'll notice I haven't talked about the modification I made, because it honestly doesn't matter. You'll need to make your own modifications anyway. FYI Because you asked, all I did was wrap each line in quotes and add a comma to the end. This is because I needed to add each line of the file to an array for making a VS Code snippet. This is one of the huge advantages; I saved myself a boatload of time in just 10 lines of code, and I can reuse these chunks of code again and again for all kinds of small but helpful projects.","title":"Reading and Writing Files"},{"location":"python/working-with-files/#working-with-the-directory","text":"It's all well and good to work with individual files themselves, and there are plenty of times that's helpful, but there are also times where you'll want to work with the filesystem itself. To do this, you'll want to work with Python's built-in os module that makes operations like this much easier.","title":"Working with the Directory"}]}